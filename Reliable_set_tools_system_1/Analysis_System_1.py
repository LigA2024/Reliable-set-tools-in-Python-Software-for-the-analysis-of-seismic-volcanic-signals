# -*- coding: utf-8 -*-

# Created by: PyQt5 UI code generator 5.15.2 and modified by later code editing
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

# Developed by: Ligdamis A. Gutiérrez E. PhD.
# Seismic Analysis System.

# Andalusian Institute of Geophysics
# Department of Theoretical Physics and the Cosmos,
# Science Faculty,
# Granada University, (Ugr), Spain, 2021 - 2025

''' WARNING: Do not modify or edit the code without permission of the author.
    In case of using this software, indicate and refer to the author and the institution he represents.
    The University of Granada, Ugr '''

# Program: Module 1 - Analysis_System_1.py -> Performs the filtering and the seismic signals spectral analysis

# Ver. 1.2 - New

# Part of the comments are written, both in English and in Castilian (Spanish).


# Load libraries to use

# For system use, threads and paths (path)
import sys
import os
import subprocess
from pathlib import Path

# Libraries for the use of PyQt5 - binding of the graphical Qt library
from PyQt5.QtWidgets import QApplication, QWidget, QMessageBox
from PyQt5 import QtCore, QtGui, QtWidgets, uic

from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton
from PyQt5.QtCore import QCoreApplication

import warnings  # Library for alerts

# Libraries for use of Wavelet Transform
# To read records through the "obspy" library
import obspy
from obspy.imaging.cm import obspy_sequential
from obspy.signal.tf_misfit import cwt
from obspy import Stream
from obspy import read
from obspy.io.sac import SACTrace
from obspy import read, Trace

# spectrum
from scipy import signal
from scipy.fftpack import fft # Fourier transform
from scipy import fft, arange

# Libraries for use of Transforms, Wawelet, Periodogram, Spectral Density
from scipy.signal import periodogram, welch

# Libraries for graphics using matplotlib and using numpy, plotly
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from matplotlib.figure import Figure

# import matplotlib.cbook as cbook
import numpy as np
import matplotlib.pyplot as plt

import pandas as pd

import plotly.graph_objects as go

# Identify the operating system
import platform
sistema = platform.system()  # Identify the operating system

# Libraries to use tkinter (Graphical interface)
import tkinter
import tkinter as tk
from tkinter.ttk import Combobox, Style
from tkinter import Frame, IntVar, Label, filedialog, Entry, Radiobutton, CURRENT

# In case of using the window as root (changes later)
from tkinter import *
root = tk.Tk()
root.withdraw()

# When using another class to import canvas from another file
from class_canvas1 import MatplotlibWidget11_sin

# Libraries to use pywt -> for wavelet transforms
import pywt
import pywt.data

# Main Class of Program Ui_MainWindow, Object: MainWindow
class Ui_MainWindow(object):
    def setupUi(self, MainWindow):   # Main function class and MainWindow object
        MainWindow.setObjectName("MainWindow")

        MainWindow.setWindowModality(QtCore.Qt.WindowModal)
        MainWindow.resize(1148, 707)
        icon = QtGui.QIcon()

        # Loading the Ugr image on the canvas
        icon.addPixmap(QtGui.QPixmap(r"Images/Ugr.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        MainWindow.setWindowIcon(icon)
        MainWindow.setToolTip("")

        self.widget = MatplotlibWidget11_sin(MainWindow)
        self.widget.setGeometry(QtCore.QRect(10, 190, 1131, 351))
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget.sizePolicy().hasHeightForWidth())
        self.widget.setSizePolicy(sizePolicy)
        self.widget.setFocusPolicy(QtCore.Qt.StrongFocus)
        self.widget.setAutoFillBackground(True)
        self.widget.setObjectName("widget")


        # Set frame group 1 - *************************************************

        self.frame = QtWidgets.QFrame(MainWindow)
        self.frame.setGeometry(QtCore.QRect(310, 150, 831, 31))
        self.frame.setAutoFillBackground(True)
        self.frame.setFrameShape(QtWidgets.QFrame.Box)
        self.frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame.setObjectName("frame")

        self.label_7 = QtWidgets.QLabel(self.frame)
        self.label_7.setGeometry(QtCore.QRect(10, 10, 821, 16))
        self.label_7.setObjectName("label_7")

        self.line_8 = QtWidgets.QFrame(MainWindow)
        self.line_8.setGeometry(QtCore.QRect(10, 540, 461, 20))
        self.line_8.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_8.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_8.setObjectName("line_8")

        self.line_9 = QtWidgets.QFrame(MainWindow)
        self.line_9.setGeometry(QtCore.QRect(10, 620, 1131, 16))
        self.line_9.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_9.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_9.setObjectName("line_9")

        self.line_13 = QtWidgets.QFrame(MainWindow)
        self.line_13.setGeometry(QtCore.QRect(670, 540, 471, 20))
        self.line_13.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_13.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_13.setObjectName("line_13")

        self.label_8 = QtWidgets.QLabel(MainWindow)
        self.label_8.setGeometry(QtCore.QRect(498, 530, 181, 41))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(30)
        font.setBold(True)
        font.setItalic(True)
        font.setWeight(75)
        self.label_8.setFont(font)
        self.label_8.setObjectName("label_8")


        # Set frame group 2 - *************************************************

        self.frame_2 = QtWidgets.QFrame(MainWindow)
        self.frame_2.setGeometry(QtCore.QRect(10, 20, 1131, 121))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.frame_2.setPalette(palette)
        self.frame_2.setAutoFillBackground(True)
        self.frame_2.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_2.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_2.setObjectName("frame_2")

        self.pushButton = QtWidgets.QPushButton(self.frame_2)
        self.pushButton.setGeometry(QtCore.QRect(30, 20, 91, 31))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.pushButton.setPalette(palette)
        self.pushButton.setAutoFillBackground(True)

        # Loading the image of the 'Load' icon on the button
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(r"Images/Load.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton.setIcon(icon1)
        self.pushButton.setObjectName("pushButton")         # Upload file button (Load Record)

        self.pushButton_2 = QtWidgets.QPushButton(self.frame_2)
        self.pushButton_2.setGeometry(QtCore.QRect(30, 80, 91, 31))

        # Loading the image of the 'Clean' icon on the button
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap(r"Images/Clean.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_2.setIcon(icon2)
        self.pushButton_2.setObjectName("pushButton_2")    # Clean inputs button

        # Set  groupBox1 for comboBox 1- *************************************************
        self.groupBox = QtWidgets.QGroupBox(self.frame_2)
        self.groupBox.setGeometry(QtCore.QRect(800, 10, 311, 101))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 254, 219))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 254, 219))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 254, 219))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 254, 219))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.groupBox.setPalette(palette)
        self.groupBox.setAutoFillBackground(True)
        self.groupBox.setCheckable(False)
        self.groupBox.setObjectName("groupBox")

        self.comboBox = QtWidgets.QComboBox(self.groupBox)
        self.comboBox.setGeometry(QtCore.QRect(20, 20, 272, 22))
        self.comboBox.setObjectName("comboBox")                     # Combo Box, for spectral analysis.
        self.comboBox.addItem("")                                   # Value 0, for the start "Select".
        self.comboBox.addItem("")                                   # Value 1, for the Fourier Spectrum in Frequency.
        self.comboBox.addItem("")                                   # Value 2, for the spectrogram.
        self.comboBox.addItem("")                                   # Value 3, for the spectrogram with filter signal.
        self.comboBox.addItem("")                                   # Value 4, for the Envelope of the signal.
        self.comboBox.addItem("")                                   # Value 5, for the power spectral density using the Welch method.
        self.comboBox.addItem("")                                   # Value 6, for the Classical periodogram plus five types of Welch window.
        self.comboBox.addItem("")                                   # Value 7, for the Continuous Wavelet Transform (CWT).
        self.comboBox.addItem("")                                   # Value 8, for the Discrete Wavelet Coefficients.

        # Set  groupBox2 for comboBox 2- *************************************************

        self.groupBox_2 = QtWidgets.QGroupBox(self.frame_2)
        self.groupBox_2.setGeometry(QtCore.QRect(170, 10, 211, 101))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(240, 255, 247))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 255, 247))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 255, 247))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.groupBox_2.setPalette(palette)
        self.groupBox_2.setAutoFillBackground(True)
        self.groupBox_2.setObjectName("groupBox_2")

        self.comboBox_2 = QtWidgets.QComboBox(self.groupBox_2)
        self.comboBox_2.setGeometry(QtCore.QRect(10, 20, 191, 22))
        self.comboBox_2.setObjectName("comboBox_2")                 # Combo Box, for Filter types
        self.comboBox_2.addItem("")                                 # Value 0, for the start "Select"
        self.comboBox_2.addItem("")                                 # Value 1, for Lowpass filter
        self.comboBox_2.addItem("")                                 # Value 2, for Highpass filter
        self.comboBox_2.addItem("")                                 # Value 3, for Bandpass filter
        self.comboBox_2.addItem("")                                 # Value 4, for Bandstop filter

        """ --- Values for Text Labels (Label) Frame 2 --- """

        self.label_4 = QtWidgets.QLabel(self.frame_2)               # Frequency Label (Hz)"
        self.label_4.setGeometry(QtCore.QRect(400, 53, 111, 16))
        self.label_4.setObjectName("label_4")

        self.label_5 = QtWidgets.QLabel(self.frame_2)
        self.label_5.setGeometry(QtCore.QRect(420, 80, 91, 16))
        self.label_5.setObjectName("label_5")

        self.label_6 = QtWidgets.QLabel(self.frame_2)
        self.label_6.setGeometry(QtCore.QRect(420, 100, 91, 16))
        self.label_6.setObjectName("label_6")

        self.label_17 = QtWidgets.QLabel(self.frame_2)
        self.label_17.setGeometry(QtCore.QRect(630, 100, 91, 16))
        self.label_17.setObjectName("label_17")

        self.label_18 = QtWidgets.QLabel(self.frame_2)
        self.label_18.setGeometry(QtCore.QRect(630, 90, 91, 16))
        self.label_18.setObjectName("label_18")

        self.label_10 = QtWidgets.QLabel(self.frame_2)              # Contains an image (Instituto Andaluz de Geofísica, IAG).
        self.label_10.setGeometry(QtCore.QRect(650, 5, 111, 81))
        self.label_10.setText("")

        # The image (IAG) is loaded on the canvas through a label
        self.label_10.setPixmap(QtGui.QPixmap(r"Images/IAG.gif"))
        self.label_10.setScaledContents(True)
        self.label_10.setObjectName("label_10")

        self.label_12 = QtWidgets.QLabel(self.frame_2)
        self.label_12.setGeometry(QtCore.QRect(470, 0, 91, 16))
        self.label_12.setObjectName("label_12")

        self.label_13 = QtWidgets.QLabel(self.frame_2)
        self.label_13.setGeometry(QtCore.QRect(420, 2, 51, 16))
        self.label_13.setObjectName("label_13")

        self.label_14 = QtWidgets.QLabel(self.frame_2)
        self.label_14.setGeometry(QtCore.QRect(560, 2, 61, 16))
        self.label_14.setObjectName("label_14")

        self.label_15 = QtWidgets.QLabel(self.frame_2)
        self.label_15.setGeometry(QtCore.QRect(540, 53, 111, 16))
        self.label_15.setObjectName("label_15")

        self.label_16 = QtWidgets.QLabel(self.frame_2)
        self.label_16.setGeometry(QtCore.QRect(543, 63, 111, 16))
        self.label_16.setObjectName("label_16")

        """ --- Values for Text Boxes (lineEdit) Frame 2 --- """

        self.lineEdit = QtWidgets.QLineEdit(self.frame_2)           # Text box for frequency filter
        self.lineEdit.setGeometry(QtCore.QRect(511, 53, 51, 20))
        self.lineEdit.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit.setAlignment(QtCore.Qt.AlignCenter)
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)  # Only lowercase characters allowed.
        self.lineEdit.setObjectName("lineEdit")

        self.lineEdit_8 = QtWidgets.QLineEdit(self.frame_2)         # Text Box for Discrete Wavelets Coefficients.
        self.lineEdit_8.setGeometry(QtCore.QRect(511, 53, 51, 20))
        # Qt.ImhLowercaseOnly -> Only lowercase characters allowed
        self.lineEdit_8.setInputMethodHints(QtCore.Qt.ImhLowercaseOnly)
        self.lineEdit_8.setObjectName("lineEdit_8")

        self.lineEdit_2 = QtWidgets.QLineEdit(self.frame_2)     # Minimum Frequency text box
        self.lineEdit_2.setGeometry(QtCore.QRect(511, 78, 51, 20))
        self.lineEdit_2.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_2.setAlignment(QtCore.Qt.AlignCenter)
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_2.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_2.setObjectName("lineEdit_2")

        self.lineEdit_3 = QtWidgets.QLineEdit(self.frame_2)     # Maximum Frequency text box
        self.lineEdit_3.setGeometry(QtCore.QRect(511, 100, 51, 20))
        self.lineEdit_3.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_3.setAlignment(QtCore.Qt.AlignCenter)
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_3.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        self.lineEdit_3.setObjectName("lineEdit_3")

        self.lineEdit_4 = QtWidgets.QLineEdit(self.frame_2)     # NFFT text box.
        self.lineEdit_4.setGeometry(QtCore.QRect(420, 20, 51, 20))
        self.lineEdit_4.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_4.setAlignment(QtCore.Qt.AlignCenter)
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_4.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        rx  = QtCore.QRegExp("[0-9]{9999}")       # Format to only allow 4 integers
        val = QtGui.QRegExpValidator(rx)
        self.lineEdit_4.setValidator(val)
        self.lineEdit_4.setObjectName("lineEdit_4")

        self.lineEdit_5 = QtWidgets.QLineEdit(self.frame_2)     # Overlap text box.
        self.lineEdit_5.setGeometry(QtCore.QRect(560, 20, 51, 20))
        self.lineEdit_5.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_5.setAlignment(QtCore.Qt.AlignCenter)
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_5.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        rx1  = QtCore.QRegExp("[0-9]{9999}")      # Format to only allow 4 integers
        val1 = QtGui.QRegExpValidator(rx1)
        self.lineEdit_5.setValidator(val1)
        self.lineEdit_5.setObjectName("lineEdit_5")

        self.lineEdit_6 = QtWidgets.QLineEdit(self.frame_2)  # Filter Order Text Box
        self.lineEdit_6.setGeometry(QtCore.QRect(569, 78, 51, 20))
        self.lineEdit_6.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_6.setAlignment(QtCore.Qt.AlignCenter)
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_6.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        rx2  = QtCore.QRegExp("[0-9]{999}")      # Format to only allow 3 integers
        val2 = QtGui.QRegExpValidator(rx2)
        self.lineEdit_6.setValidator(val2)
        self.lineEdit_6.setObjectName("lineEdit_6")

        self.lineEdit_7 = QtWidgets.QLineEdit(self.frame_2)   # Fs text box
        self.lineEdit_7.setGeometry(QtCore.QRect(490, 20, 51, 20))
        self.lineEdit_7.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_7.setAlignment(QtCore.Qt.AlignCenter)
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_7.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        rx3  = QtCore.QRegExp("[0-9]{9999}")      # Format to only allow 4 integers
        val3 = QtGui.QRegExpValidator(rx3)
        self.lineEdit_7.setValidator(val3)
        self.lineEdit_7.setObjectName("lineEdit_7")

        self.lineEdit_9 = QtWidgets.QLineEdit(self.frame_2)     # Trace Number text box -> ts[0]
        self.lineEdit_9.setGeometry(QtCore.QRect(721, 95, 51, 20))
        self.lineEdit_9.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_9.setAlignment(QtCore.Qt.AlignCenter)
        # Qt.ImhFormattedNumbersOnly -> Only allows the use of numbers including decimals and sign (-)
        self.lineEdit_9.setInputMethodHints(QtCore.Qt.ImhFormattedNumbersOnly)
        rx4  = QtCore.QRegExp("[0-9]{99999}")      # Format to only allow 5 integers
        val4 = QtGui.QRegExpValidator(rx4)
        self.lineEdit_9.setValidator(val4)
        self.lineEdit_9.setObjectName("lineEdit_9")

        """ --- Values for the separation lines on the canvas (line) Frame 2 --- """

        self.line = QtWidgets.QFrame(self.frame_2)
        self.line.setGeometry(QtCore.QRect(390, 0, 20, 121))
        self.line.setFrameShape(QtWidgets.QFrame.VLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")

        self.line_2 = QtWidgets.QFrame(self.frame_2)
        self.line_2.setGeometry(QtCore.QRect(620, 0, 20, 121))
        self.line_2.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_2.setObjectName("line_2")

        self.line_3 = QtWidgets.QFrame(self.frame_2)
        self.line_3.setGeometry(QtCore.QRect(140, 0, 20, 121))
        self.line_3.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_3.setObjectName("line_3")

        self.line_4 = QtWidgets.QFrame(self.frame_2)
        self.line_4.setGeometry(QtCore.QRect(0, 60, 151, 16))
        self.line_4.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_4.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_4.setObjectName("line_4")

        self.line_11 = QtWidgets.QFrame(self.frame_2)
        self.line_11.setGeometry(QtCore.QRect(770, 0, 20, 121))
        self.line_11.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_11.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_11.setObjectName("line_11")

        self.line_12 = QtWidgets.QFrame(self.frame_2)
        self.line_12.setGeometry(QtCore.QRect(400, 40, 231, 20))
        self.line_12.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_12.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_12.setObjectName("line_12")

        self.label_3 = QtWidgets.QLabel(MainWindow)   # Label of "Graph of the Spectral Analysis of the Seismic Record"
        self.label_3.setGeometry(QtCore.QRect(12, 148, 291, 41))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(36)
        font.setBold(True)
        font.setItalic(True)
        font.setWeight(75)
        self.label_3.setFont(font)
        self.label_3.setObjectName("label_3")


        # Set frame group 3 - *************************************************

        self.frame_3 = QtWidgets.QFrame(MainWindow)
        self.frame_3.setGeometry(QtCore.QRect(10, 640, 1131, 61))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 254, 219))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 254, 219))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 254, 219))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.frame_3.setPalette(palette)
        self.frame_3.setAutoFillBackground(True)
        self.frame_3.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_3.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_3.setObjectName("frame_3")

        self.pushButton_3 = QtWidgets.QPushButton(self.frame_3)    # ----- Image Back
        self.pushButton_3.setGeometry(QtCore.QRect(20, 10, 101, 41))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)
        self.pushButton_3.setPalette(palette)
        self.pushButton_3.setAutoFillBackground(True)
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap(r"Images/Back.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_3.setIcon(icon3)
        self.pushButton_3.setObjectName("pushButton_3")     # Command button to return to the Home screen

        self.pushButton_4 = QtWidgets.QPushButton(self.frame_3)    # ----- Image Exit
        self.pushButton_4.setGeometry(QtCore.QRect(1010, 10, 101, 41))
        icon4 = QtGui.QIcon()
        icon4.addPixmap(QtGui.QPixmap(r"Images/Exit.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_4.setIcon(icon4)
        self.pushButton_4.setObjectName("pushButton_4")     # Command Button for System Exit

        self.label_2 = QtWidgets.QLabel(self.frame_3)       # where the seismic log path will be placed
        self.label_2.setGeometry(QtCore.QRect(170, 20, 481, 31))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(240, 255, 247))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 255, 247))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 255, 247))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.label_2.setPalette(palette)
        self.label_2.setFocusPolicy(QtCore.Qt.StrongFocus)
        self.label_2.setAutoFillBackground(True)
        self.label_2.setText("")
        self.label_2.setObjectName("label_2")

        self.label = QtWidgets.QLabel(self.frame_3)     # Label "File Path"
        self.label.setGeometry(QtCore.QRect(160, 0, 91, 21))
        self.label.setObjectName("label")

        self.line_5 = QtWidgets.QFrame(self.frame_3)
        self.line_5.setGeometry(QtCore.QRect(150, 0, 3, 61))
        self.line_5.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_5.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_5.setObjectName("line_5")

        self.line_6 = QtWidgets.QFrame(self.frame_3)
        self.line_6.setGeometry(QtCore.QRect(960, 0, 20, 61))
        self.line_6.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_6.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_6.setObjectName("line_6")

        self.pushButton_5 = QtWidgets.QPushButton(self.frame_3)     # ----- Image Filter
        self.pushButton_5.setGeometry(QtCore.QRect(680, 10, 101, 41))
        icon5 = QtGui.QIcon()
        icon5.addPixmap(QtGui.QPixmap(r"Images/Filter.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_5.setIcon(icon5)
        self.pushButton_5.setObjectName("pushButton_5")     # Command button for signal filtering graph

        self.line_7 = QtWidgets.QFrame(self.frame_3)
        self.line_7.setGeometry(QtCore.QRect(660, 0, 3, 61))
        self.line_7.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_7.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_7.setObjectName("line_7")

        self.line_10 = QtWidgets.QFrame(self.frame_3)
        self.line_10.setGeometry(QtCore.QRect(800, 0, 3, 61))
        self.line_10.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_10.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_10.setObjectName("line_10")

        self.pushButton_6 = QtWidgets.QPushButton(self.frame_3)     # ----- Image Analysis
        self.pushButton_6.setGeometry(QtCore.QRect(840, 10, 101, 41))
        icon6 = QtGui.QIcon()
        icon6.addPixmap(QtGui.QPixmap(r"Images/Analysis.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_6.setIcon(icon6)
        self.pushButton_6.setObjectName("pushButton_6")     # Command button for the Spectral Analysis graph


        # Set frame group 4 - *************************************************

        self.frame_4 = QtWidgets.QFrame(MainWindow)
        self.frame_4.setGeometry(QtCore.QRect(10, 560, 1131, 61))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.frame_4.setPalette(palette)
        self.frame_4.setAutoFillBackground(True)
        self.frame_4.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_4.setFrameShadow(QtWidgets.QFrame.Plain)
        self.frame_4.setLineWidth(2)
        self.frame_4.setObjectName("frame_4")

        self.label_9 = QtWidgets.QLabel(self.frame_4)
        self.label_9.setGeometry(QtCore.QRect(10, 0, 1111, 61))
        self.label_9.setObjectName("label_9")


        """ --- Miscellaneous Values --- """

        # Color and text formatting on Command Buttons
        self.pushButton.setStyleSheet("background-color: honeydew; color: blue")            # Text and Color of the Command Button (load File)
        self.pushButton_2.setStyleSheet("background-color: gold; color: blue")              # Text and Color of the Command Button (clean input)
        self.pushButton_3.setStyleSheet("background-color: CornflowerBlue; color: white")   # Text and Color of the Command Button (Back)
        self.pushButton_4.setStyleSheet("background-color: burlywood; color: blue")         # Text and Color of the Command Button (Exit)
        self.pushButton_5.setStyleSheet("background-color: silver; color: blue")            # Text and Color of the Command Button (graph filters)
        self.pushButton_6.setStyleSheet("background-color: lightsalmon; color: blue")       # Text and Color of the Command Button (Plot Spectral Analysis)

        self.label_11 = QtWidgets.QLabel(MainWindow)
        self.label_11.setGeometry(QtCore.QRect(18, 170, 310, 41))
        self.label_11.setObjectName(u"label_11")

        """ --- Values for dynamic Text boxes (textEdit and textEdit_2) --- """

        self.textEdit = QtWidgets.QTextEdit(self.widget)                                    # Text box that will contain the metadata information
        self.textEdit.setGeometry(QtCore.QRect(15, 15, 541, 320))
        self.textEdit.setObjectName("textEdit")

        self.textEdit_2 = QtWidgets.QTextEdit(self.widget)                                  # Text box that will contain the information of the traces of the seismic record
        self.textEdit_2.setGeometry(QtCore.QRect(560, 15, 555, 320))
        self.textEdit_2.setObjectName("textEdit_2")

        self.retranslateUi(MainWindow)

    """  The formats and contents for the initial interface are established. """
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Reading and Seismic Signals Analysis (Vers. 2.1) - Granada University (Ugr)"))

        self.groupBox.setTitle(_translate("MainWindow", "Analysis Selection "))                                       # Combobox title
        self.comboBox.setItemText(0, _translate("MainWindow", "Please select"))                                       # Index 0 - Please select
        self.comboBox.setItemText(1, _translate("MainWindow", "Fourier Spectrum in Frequency Domain"))                # Index 1 - Fourier
        self.comboBox.setItemText(2, _translate("MainWindow", "Spectrogram x FFT method "))                           # Index 2 - Spectrogram
        self.comboBox.setItemText(3, _translate("MainWindow", "Spectrogram with Bandpass Filter signal"))             # Index 3 - Spectrogram with Bandpass Filter
        self.comboBox.setItemText(4, _translate("MainWindow", "Envelope / Filtered Register (Lowpass)"))              # Index 4 - Envelope
        self.comboBox.setItemText(5, _translate("MainWindow", "Spectral Power Density by Welch"))                     # Index 5 - PSD
        self.comboBox.setItemText(6, _translate("MainWindow", "Classical periodogram plus 5 Welch types "))           # Index 6 - Periodogram.
        self.comboBox.setItemText(7, _translate("MainWindow", "Continuous Wavelet Transform (CWT)"))                  # Index 7 - Wavelet (CWT)
        self.comboBox.setItemText(8, _translate("MainWindow", "Discrete Wavelet Coefficient Analysis "))              # Index 8 - Discrete Wavelet Coefficient

        self.groupBox_2.setTitle(_translate("MainWindow", "Filter Type"))                                             # Combobox title
        self.comboBox_2.setItemText(0, _translate("MainWindow", "Please select"))                                     # Index 0 - Please select
        self.comboBox_2.setItemText(1, _translate("MainWindow", "Lowpass Filter"))                                    # Index 1 - Lowpass
        self.comboBox_2.setItemText(2, _translate("MainWindow", "Highpass Filter"))                                   # Index 2 - Highpass
        self.comboBox_2.setItemText(3, _translate("MainWindow", "Bandpass Filter"))                                   # Index 3 - Bandpass
        self.comboBox_2.setItemText(4, _translate("MainWindow", "Bandstop Filter"))                                   # Index 4 - Bandstop

        self.pushButton.setText(_translate("MainWindow", "  Load"))                                                   # pushButton name - Load
        self.pushButton_2.setText(_translate("MainWindow", " Cleaning"))                                              # pushButton2 name - Cleaning
        self.pushButton_3.setText(_translate("MainWindow", "  Back"))                                                 # pushButton3 name - Back
        self.pushButton_4.setText(_translate("MainWindow", "  Exit"))                                                 # pushButton4 name - Exit
        self.pushButton_5.setText(_translate("MainWindow", "  Filter"))                                               # pushButton5 name - Filter
        self.pushButton_6.setText(_translate("MainWindow", " Analysis"))                                              # pushButton6 name - Analysis

        self.pushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#00007f;\">Search Register</span></p></body></html>"))
        self.pushButton_2.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#00007f;\">Clean the Inputs</span></p></body></html>"))
        self.pushButton_3.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#aa0000;\">Back Home</span></p></body></html>"))
        self.pushButton_4.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#aa0000;\">Exit System</span></p></body></html>"))
        self.pushButton_5.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#00007f;\">Graphic Signal</span></p></body></html>"))
        self.pushButton_6.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#00007f;\">Spec. Analysis</span></p></body></html>"))

        self.label.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:9pt; font-weight:600; color:#aa0000;\">File Path:</span></p></body></html>"))
        self.label_3.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:12pt; color:#0000ff;\">Spectral Analysis Registry Graph:</span></p></body></html>"))
        self.label_4.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Filter Freq. (Hz):</span></p></body></html>"))
        self.label_5.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Min Freq. (Hz):</span></p></body></html>"))
        self.label_6.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Max Freq. (Hz):</span></p></body></html>"))
        self.label_7.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#00007f;\">The &quot;obspy&quot;,library is used to read the seismic records, according to the various formats, and the &quot;Matplotlib&quot; library is used to graph the seismic signals.</span></p></body></html>"))
        self.label_8.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:10pt; color:#aa0000;\">Seismic Record Statistics</span></p></body></html>"))
        self.label_9.setText(_translate("MainWindow", "<html><head/><body><p align=\"justify\"><span style=\" font-size:7pt;\">Registry Statistics are:</span></p></body></html>"))
        self.label_11.setText(_translate("MainWindow", u"Metadata (Header of each trace) of the Registry and Trace No.:", None))   # Present the label, metadata on the desktop
        self.label_12.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; color:#aa5500;\">Fs:</span></p></body></html>"))
        self.label_13.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; color:#aa5500;\">NFFT:</span></p></body></html>"))
        self.label_14.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; color:#aa5500;\">Overlap:</span></p></body></html>"))
        self.label_15.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#aa5500;\">Filter Order</span></p></body></html>"))
        self.label_16.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#aa5500;\">By default = 4</span></p></body></html>"))
        self.label_17.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:6pt; font-weight:550; font-style:italic; color:#00007f;\">By default: st(0) </span></p></body></html>"))
        self.label_18.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:6pt; font-weight:550; color:#aa5500;\">Trace Number st(n): </span></p></body></html>"))

        # Command button actions, function calls
        self.pushButton.clicked.connect(self.abrir_archivo2)            # Call the function to upload file (Load File).
        self.pushButton_2.clicked.connect(self.limpiar_entradas)        # Calls the function to clean entries (Clean Entries).
        self.pushButton_3.clicked.connect(self.abrir_programa1)         # Call the function to return to the Home Screen (Back).
        self.pushButton_4.clicked.connect(self.Exit1)                   # Call the function to exit the System (Exit).
        self.pushButton_5.clicked.connect(self.verificar)               # Call the function to graph the filter records (Filter).
        self.pushButton_6.clicked.connect(self.editar)                  # Calls the function to graph the spectral analysis (Analysis).

        # Validate so that only decimal numbers are accepted "QIntValidator": For "integers", you must put "QIntValidator".
        self.lineEdit.setValidator(QtGui.QDoubleValidator())            # Only accepts numbers in the Filter Frequency text box.
        self.lineEdit_2.setValidator(QtGui.QDoubleValidator())          # Only accepts numbers in the Minimum Frequency text box.
        self.lineEdit_3.setValidator(QtGui.QDoubleValidator())          # Only accepts numbers in the Max Frequency text box.

       # The value (1,999) indicates that only up to 4 integer positions are to be used.
        self.lineEdit_4.setValidator(QtGui.QIntValidator(1, 9999))      # Only accepts numbers in the NFFT text box. Default value 256 x 2.
        self.lineEdit_5.setValidator(QtGui.QIntValidator(1, 9999))      # Only accepts numbers in the Overlap number text box. Default value 128.
        self.lineEdit_6.setValidator(QtGui.QIntValidator(1, 99))        # Only accepts numbers in the Filter order text box. Two-digit value.
        self.lineEdit_7.setValidator(QtGui.QIntValidator(1, 99999))     # Only accepts numbers in the Fs text box. Value three digits.
        self.lineEdit_9.setValidator(QtGui.QIntValidator(1, 99999))     # Only accepts numbers in the Filter Order text box. Value Two digits.

        # Disable text boxes initially
        self.lineEdit.setEnabled(False)                                 # Deactivate the Frequency Text box.
        self.lineEdit_2.setEnabled(False)                               # Disables the minimum frequency text box. / (Min. Time).
        self.lineEdit_3.setEnabled(False)                               # Disables the maximum frequency text box. / (Max Time).
        self.lineEdit_4.setEnabled(False)                               # Disable the NFFT text box.
        self.lineEdit_5.setEnabled(False)                               # Disable the overlap text box.
        self.lineEdit_6.setEnabled(False)                               # Deactivate the Filter Order Text box.
        self.lineEdit_7.setEnabled(False)                               # Disable the Fs text box.
        self.lineEdit_9.setEnabled(False)                               # Disable Trece No. st[0] Text box.
        self.lineEdit_6.setText("4")                                    # Inicia contenido de caja de texto de orden de filtro = 4.
        self.lineEdit_9.setText("0")                                    # Inicia contenido de caja de texto de Nº de Traza st[0].

        # The tabulation order of the text boxes for the Spectrogram is established, (Because they were created in a different order).
        MainWindow.setTabOrder(self.lineEdit_4, self.lineEdit_7)        # NFFT first, followed by FS.
        MainWindow.setTabOrder(self.lineEdit_7, self.lineEdit_5)        # After the FS, Overlap is established.

        # Enable / Disable buttons for graphing (Disabled at startup)
        self.pushButton_5.setEnabled(False)                             # Disable the Plot button for the Filter.
        self.pushButton_6.setEnabled(False)                             # Activate the Plot button for Spectral Analysis.

        # Call to the function according to the ComboBox list for the Filter type
        self.comboBox_2.activated.connect(self.selection_changed1)

        # Call to the function according to the ComboBox list for the Analysis Selection
        self.comboBox.activated.connect(self.selection_changed2)

        self.widget.setVisible(True)

        self.lineEdit_8.setVisible(False)                                   # Initially, Hides the text box for the discrete Wavelet coefficients.

        """ ------------- Start of Program Functions  ------------ """

        """ Function to open and clean """

    def abrir_archivo2(self):                                               # Function, to search and load the records according to the format
        if sistema == "Windows":
            self.archivo_abierto=filedialog.askopenfilename(initialdir = "/",
                title = "Please, select file",filetypes = (("All Files","*.*"),
                ('SAC Files","*.sac'),
                ('MSEED Files','*.mseed'),
                ('GSE2 Files','*.gse2'),
                ('WAV Files','*.wav'),
                ('Kinemetrics Files','*.evt')))

            self.ruta = Path(self.archivo_abierto)
            self.ruta2 = self.ruta.joinpath(self.ruta).resolve()

            font=QtGui.QFont()
            font.setFamily("Times New Roman")
            font.setPointSize(8)
            font.setBold(False)
            font.setItalic(False)
            font.setWeight(60)
            self.label_2.setFont(font)                                      # Printing using text format.
            self.label_2.setText(self.archivo_abierto)                      # Printing on the file path label.

        else:
            self.archivo_abierto=filedialog.askopenfilename(initialdir = "/",
                title = "Please, select file",filetypes = (("All Files","*.*"),
                ('SAC Files","*.sac'),
                ('MSEED Files','*.mseed'),
                ('GSE2 Files','*.gse2'),
                ('WAV Files','*.wav'),
                ('Kinemetrics Files','*.evt')))

            self.ruta = Path(self.archivo_abierto)
            self.ruta2 = self.ruta.joinpath(self.ruta).resolve()

            font=QtGui.QFont()
            font.setFamily("Times New Roman")
            font.setPointSize(8)
            font.setBold(False)
            font.setItalic(False)
            font.setWeight(60)
            self.label_2.setFont(font)                                      # Printing using text format.
            self.label_2.setText(self.archivo_abierto)                      # Printing on the file path label.

    def limpiar_entradas(self):                                             # Clean and leave everything as at the beginning.

        msg = QMessageBox()
        msg.setIcon(QMessageBox.Question)
        msg.setWindowTitle("Clean all inputs.")
        msg.setText("Are you sure to delete all entries?")
        msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        msg.setDefaultButton(QMessageBox.Ok)                                    # By default, the focus is on the OK button
        returnValue = msg.exec()
        if returnValue == QMessageBox.Ok:                                       # If the answer is OK

            # Position the ComboBox at the start.
            self.comboBox.setCurrentIndex(0)                                    # Position in the first Item (Analysis Selection)
            self.comboBox_2.setCurrentIndex(0)                                  # Position in the first Item (Filter Type)
            plt.close()                                                         # Close the existing chart.

            # Delete label content and Text Boxes.
            self.label_2.setText("")                                            # Delete the contents of the File Path label
            self.lineEdit.setText("")                                           # Clear the content of the Frequency text box
            self.lineEdit_2.setText("")                                         # Clear the content of the minimum frequency text box
            self.lineEdit_3.setText("")                                         # Clear the content of the maximum frequency text box
            self.lineEdit_4.setText("")                                         # Clear the content of NFFT text box
            self.lineEdit_5.setText("")                                         # Clear the content of overlap text box
            self.lineEdit_6.setText("4")                                        # Inicia contenido de caja de texto de Orden de filtro = 4.
            self.lineEdit_7.setText("")                                         # Clear the content of the Fs text box
            self.lineEdit_8.setText("")                                         # Clear the content of the discrete Wavelets coefficients text box
            self.lineEdit_9.setText("0")                                        # Borra contenido de caja de texto de Nº de Traza st[0].
            self.label_9.setText("")                                            # Clear log statistics text box content
            self.textEdit.setText("")                                           # Clear the content of the Metadata text box
            self.textEdit_2.setText("")                                         # Borra contenido de la caja de texto de Trazas

            # Set the statistics message as at the beginning.
            self.label_9.setText("<html><head/><body><p align=\"justify\"><span style=\" font-size:7pt;\">Registry Statistics are:</span></p></body></html>")

            self.label_5.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Min Freq. (Hz):</span></p></body></html>")
            self.label_6.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Max Freq. (Hz):</span></p></body></html>")

            # Disable text boxes again as at startup
            self.lineEdit.setEnabled(False)                                     # Disable the Frequency Text box.
            self.lineEdit_2.setEnabled(False)                                   # Disable the minimum frequency text box.
            self.lineEdit_3.setEnabled(False)                                   # Disable the maximum frequency text box.
            self.lineEdit_4.setEnabled(False)                                   # Disable the NFFT text box.
            self.lineEdit_5.setEnabled(False)                                   # Disable the overlap text box.
            self.lineEdit_6.setEnabled(False)                                   # Disable the Filter Order text box.
            self.lineEdit_7.setEnabled(False)                                   # Disable the Fs text box.
            self.lineEdit_8.setEnabled(False)                                   # Disable the discrete Wavelets coefficients text box.
            self.lineEdit_9.setEnabled(False)                                   # Disable the Trace No. st[0]. text box.

            # Enable / Disable buttons for plot (Disabled at startup)
            self.pushButton_5.setEnabled(False)                                 # Disable the Plot button for the Filter.
            self.pushButton_6.setEnabled(False)                                 # Activate the Plot button for Spectral Analysis.

            # Change the text on the label to re-display Filter Frequency
            self.label_4.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Filter Freq. (Hz):</span></p></body></html>")

            plt.close()                                                     # Close the existing chart.

        else:
            pass

    """  Function to manage the filter combobox  """

    def selection_changed1(self):  # Function that programs the list of the ComboBox for the Type of Filter

        index = self.comboBox_2.currentIndex()                          # According to Combobox selection, its index is captured.

        # Activation/Deactivation of command buttons for graphing
        self.pushButton_5.setEnabled(True)                              # Disable the Plot command button for the Filter
        self.pushButton_6.setEnabled(False)                             # Activate the Plot command button for Spectral Analysis

        if (0 == index):                                                # *** In case the combo index is 0, (Select) """
            # Position the ComboBoxes at the beginning
            self.comboBox.setCurrentIndex(0)                            # Position on the first Item (Analysis Selection)
            self.activacion1()                                          # Call to the cleaning function and Activation/Deactivation 1

        elif (1 == index):                                              # *** In case the combo index is 1, (Lowpass) """
            # Position the ComboBoxes at the beginning
            self.comboBox.setCurrentIndex(0)                            # Position on the first Item (Analysis Selection)
            self.activacion2()                                          # Call to the cleaning function and Activation/Deactivation 2

        elif (2 == index):                                              # *** In case the combo index is 2, (Highpass) """
            # Position the ComboBoxes at the beginning
            self.comboBox.setCurrentIndex(0)                            # Position on the first Item (Analysis Selection)
            self.activacion2()                                          # Call to the cleaning function and Activation/Deactivation 2

        elif (3 == index):                                              # *** In case the combo index is 3, (Bandpass) """
            # Position the ComboBoxes at the beginning
            self.comboBox.setCurrentIndex(0)                            # Position on the first Item (Analysis Selection)
            self.activacion3()                                          # Call to the cleaning function and Activation/Deactivation 3

        elif (4 == index):                                              # *** In case the combo index is 3, (Bandstop) """
            # Position the ComboBoxes at the beginning
            self.comboBox.setCurrentIndex(0)                            # Position on the first Item (Analysis Selection)
            self.activacion3()                                          # Call to the cleaning function and Activation/Deactivation 3

        else:
            pass

    """ Function to manage the spectral analysis combobox  """

    def selection_changed2(self):                                       # Función que programa la lista del ComboBox para la Seleccion de Analisis

        index = self.comboBox.currentIndex()

        # Activación/Desactivación botones para graficar
        self.pushButton_5.setEnabled(False)                             # Desactiva el boton de Graficar para el Filter
        self.pushButton_6.setEnabled(True)                              # Activa el boton de Graficar para el Análisis espectral

        # Habilitar y desabilitar cajas de texto de entradas
        if (0 == index):                                                # En caso de que el índice del combo sea 0, "Seleccione"
            self.activacion4()                                          # Llamada a la función de limpieza y Activacion/Desactivación

        elif (1 == index):                                              # El índice del combo es 1, Espectro de Fourier en el dominio de la frecuecia
            self.comboBox_2.setCurrentIndex(0)                          # Posiciona en el primer Item (Tipo de Filter)
            self.activacion9()                                          # Llamada a la función de limpieza y Activacion/Desactivación

        elif (2 == index):                                              # El índice del combo es 2, Espectrograma
            # Posiciona los ComoBox al inicio
            self.comboBox_2.setCurrentIndex(0)                          # Posiciona en el primer Item (Tipo de Filter)
            self.activacion5()                                          # Llamada a la función de limpieza y Activacion/Desactivación

        elif (3 == index):                                              # El índice del combo es 2, Espectrograma con la señal filtrada
            # Posiciona los ComoBox al inicio
            self.comboBox_2.setCurrentIndex(3)                          # Posiciona en el Item 3 Para el filtro Paso-Banda (Tipo de Filtro)
            self.activacion10()                                         # Llamada a la función de limpieza y Activacion/Desactivación

        elif (4 == index):                                              # El índice del combo es 3, Envolvente
            # Posiciona los ComoBox al inicio
            self.comboBox_2.setCurrentIndex(0)                          # Posiciona en el primer Item (Tipo de Filter)
            self.activacion6()                                          # Llamada a la función de limpieza y Activacion/Desactivación

        elif (5 == index):                                              # El índice del combo es 4, Densidad Espectral de Potencia (DSP), utilizando el método de Welch
            # Posiciona los ComoBox al inicio
            self.comboBox_2.setCurrentIndex(0)                          # Posiciona en el primer Item (Tipo de Filter)
            self.activacion9()                                          # Llamada a la función de limpieza y Activacion/Desactivación

        elif (6 == index):                                              # El índice del combo es 5, Densidad Espectral
            # Posiciona los ComoBox al inicio
            self.comboBox_2.setCurrentIndex(0)                          # Posiciona en el primer Item (Tipo de Filter)
            self.activacion9()                                          # Llamada a la función de limpieza y Activacion/Desactivación

        elif (7 == index):                                              # El índice del combo es 6, Transformada Wawelet continua
            # Posiciona los ComoBox al inicio
            self.comboBox_2.setCurrentIndex(0)                          # Posiciona en el primer Item (Tipo de Filter)
            self.activacion7()                                          # Llamada a la función de limpieza y Activacion/Desactivación

        elif (8 == index):                                              # El índice del combo es 8, Análisis de Coeficientes Wawelet discretos
            # Posiciona los ComoBox al inicio
            self.comboBox_2.setCurrentIndex(0)                          # Posiciona en el primer Item (Tipo de Filter)
            self.activacion8()                                          # Llamada a la función de limpieza y Activacion/Desactivación

        else:
            pass

    """ Function to handle the activation / deactivation of text boxes in filters  """

    def activacion1(self):                                              # To Activate / Deactivate and cleaning in "Selection" -> Index 0.

        plt.close()                                                     # Close the existing chart.

        # Clean entrances.
        self.lineEdit.setText("")                                       # Clear the content of the Frequency text box.
        self.lineEdit_2.setText("")                                     # Clear the content of the minimum frequency text box.
        self.lineEdit_3.setText("")                                     # Clear the content of the maximum frequency text box.
        self.lineEdit_4.setText("")                                     # Clear the content of NFFT text box.
        self.lineEdit_5.setText("")                                     # Clear the content of overlap text box.
        self.lineEdit_6.setText("4")                                    # Inicia contenido de caja de texto de Orden de filtro = 4.
        self.lineEdit_7.setText("")                                     # Clear the content of the Fs text box.
        self.lineEdit_8.setText("")                                     # Clear the content of the discrete Wavelets coefficients text box.
        self.lineEdit_9.setText("0")                                    # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.textEdit.setText("")                                       # Clear the content of the Metadata text box.
        self.textEdit_2.setText("")                                     # Clear the content of the Trace text Bbox.

        # Enable and disable input text boxes.
        self.lineEdit.setEnabled(False)                                  # Disable the Frequency Text box.
        self.lineEdit_2.setEnabled(False)                                # Disable the minimum frequency text box.
        self.lineEdit_3.setEnabled(False)                                # Disable the maximum frequency text box.
        self.lineEdit_4.setEnabled(False)                                # Disable the NFFT text box.
        self.lineEdit_5.setEnabled(False)                                # Disable the overlap text box.
        self.lineEdit_6.setEnabled(False)                                # Disable the Filter Order text box.
        self.lineEdit_7.setEnabled(False)                                # Disable the Fs text box.
        self.lineEdit_8.setEnabled(False)                                # Disable the discrete Wavelets coefficients text box.
        self.lineEdit_9.setEnabled(False)                                # Disable the Trace No. st[0] text box.

        # Coloca el mensaje de las estadistica como al inicio
        self.label_9.setText("<html><head/><body><p align=\"justify\"><span style=\" font-size:7pt;\">Registry Statistics are:</span></p></body></html>")

        # Activación/Desactivación botones para graficar
        self.pushButton_5.setEnabled(False)                               # Desactiva el boton de Graficar para el Filter

        self.label_5.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Min Freq. (Hz):</span></p></body></html>")
        self.label_6.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Max Freq. (Hz):</span></p></body></html>")

        # Change the text on the label, to present Filter Frequency again.
        self.label_4.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Filter Freq. (Hz):</span></p></body></html>")

        self.lineEdit_8.setVisible(False)           # Hides the text box, for the discrete Wavelets coefficients.

        plt.close()                                 # Close the existing chart.

    def activacion2(self):                          # To Activate/Deactivate and clean in Lowpass and Highpass.

        plt.close()                                 # Close the existing chart.

        # Clean inputs
        self.lineEdit_2.setText("")                 # Borra contenido de caja de texto de frecuencia mínima
        self.lineEdit_3.setText("")                 # Borra contenido de caja de texto de frecuencia máxima
        self.lineEdit_4.setText("")                 # Borra contenido de la caja de texto de NFFT.
        self.lineEdit_5.setText("")                 # Borra contenido de la caja de texto de Noverlap.
        self.lineEdit_7.setText("")                 # Borra contenido de caja de texto de Fs.
        self.lineEdit_8.setText("")                 # Borra contenido de caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_6.setText("4")                # Inicia contenido de caja de texto de Orden de filtro = 4.
        self.lineEdit_9.setText("0")                # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.textEdit.setText("")                   # Borra contenido de la caja de texto de Metadatos
        self.textEdit_2.setText("")                 # Borra el contenido de la caja de texto de Trazas

        # Enable/Disable text boxes
        self.lineEdit.setEnabled(True)              # Activa la caja de Texto de Frecuencia.
        self.lineEdit_2.setEnabled(False)           # Desactiva la caja de Texto de frecuencia mínima.
        self.lineEdit_3.setEnabled(False)           # Desactiva la caja de Texto de frecuencia máxima.
        self.lineEdit_4.setEnabled(False)           # Desactiva la caja de Texto de NFFT.
        self.lineEdit_5.setEnabled(False)           # Desactiva la caja de Texto de overlap.
        self.lineEdit_6.setEnabled(True)            # Activa la caja de Texto de Orden del Filter
        self.lineEdit_7.setEnabled(False)           # Desactiva la caja de texto de Fs
        self.lineEdit_8.setEnabled(False)           # Desactiva la caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setEnabled(True)            # Activa la caja de texto de Nº de Traza st[0].

        self.label_5.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Min Freq. (Hz):</span></p></body></html>")
        self.label_6.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Max Freq. (Hz):</span></p></body></html>")

        # Cambia el texto en la etiqueta para presentar de nuevo Frecuencia del Filter
        self.label_4.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Filter Freq. (Hz):</span></p></body></html>")

        self.lineEdit_8.setVisible(False)           # Oculta la caja de texto para los coeficientes discretos Wavelets

        plt.close()                                 # Close the existing chart.

    def activacion3(self):                          # Para Activar/Desactivar y limpieza en Bandpass y Bandstop

        plt.close()                                 # Close the existing chart.

        # Limpiar entradas
        self.lineEdit.setText("")                   # Borra contenido de caja de texto de Frecuencia.
        self.lineEdit_4.setText("")                 # Borra contenido de la caja de texto de NFFT.
        self.lineEdit_5.setText("")                 # Borra contenido de la caja de texto de Noverlap.
        self.lineEdit_6.setText("4")                # Inicia contenido de caja de texto de Orden de filtro = 4.
        self.lineEdit_7.setText("")                 # Borra contenido de caja de texto de Fs.
        self.lineEdit_8.setText("")                 # Borra contenido de caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setText("0")                # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.textEdit.setText("")                   # Borra contenido de la caja de texto de Metadatos
        self.textEdit_2.setText("")                 # Borra el contenido de la caja de texto de Trazas

        # Activa/Desactiva cajas de texto
        self.lineEdit.setEnabled(False)             # Desactiva la caja de Texto de Frecuencia.
        self.lineEdit_2.setEnabled(True)            # Activa la caja de Texto de frecuencia mínima.
        self.lineEdit_3.setEnabled(True)            # Activa la caja de Texto de frecuencia máxima.
        self.lineEdit_4.setEnabled(False)           # Desactiva la caja de Texto de NFFT.
        self.lineEdit_5.setEnabled(False)           # Desactiva la caja de Texto de overlap.
        self.lineEdit_6.setEnabled(True)            # Activa la caja de Texto de Orden del Filter
        self.lineEdit_7.setEnabled(False)           # Desactiva la caja de texto de Fs
        self.lineEdit_8.setEnabled(False)           # Desactiva la caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setEnabled(True)            # Activa la caja de texto de Nº de Traza st[0].

        self.label_5.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Min Freq. (Hz):</span></p></body></html>")
        self.label_6.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Max Freq. (Hz):</span></p></body></html>")

        # Cambia el texto en la etiqueta para presentar de nuevo Frecuencia del Filter
        self.label_4.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Filter Freq. (Hz):</span></p></body></html>")

        self.lineEdit_8.setVisible(False)           # Oculta la caja de texto para los coeficientes discretos Wavelets

        plt.close()                                 # Close the existing chart.


    """ Function to handle the activation / deactivation of text boxes in spectral analysis  """

    def activacion4(self):

        self.comboBox_2.setCurrentIndex(0)          # Posiciona en el primer Item (Selección de Análisis)

        plt.close()                                 # Close the existing chart.

        # Limpiar entradas
        self.lineEdit.setText("")                   # Borra contenido de caja de texto de Frecuencia.
        self.lineEdit_2.setText("")                 # Borra contenido de caja de texto de frecuencia mínima.
        self.lineEdit_3.setText("")                 # Borra contenido de caja de texto de frecuencia máxima.
        self.lineEdit_4.setText("")                 # Borra contenido de la caja de texto de NFFT.
        self.lineEdit_5.setText("")                 # Borra contenido de la caja de texto de overlap.
        self.lineEdit_6.setText("4")                # Inicia contenido de caja de texto de Orden de filtro = 4.
        self.lineEdit_7.setText("")                 # Borra contenido de caja de texto de Fs.
        self.lineEdit_8.setText("")                 # Borra contenido de caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setText("0")                # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.textEdit.setText("")                   # Borra contenido de la caja de texto de Metadatos
        self.textEdit_2.setText("")                 # Borra el contenido de la caja de texto de Trazas

        # Habilitar y desabilitar cajas de texto de entradas
        self.lineEdit.setEnabled(False)             # Desactiva la caja de Texto de Frecuencia.
        self.lineEdit_2.setEnabled(False)           # Desactiva la caja de Texto de frecuencia mínima.
        self.lineEdit_3.setEnabled(False)           # Desactiva la caja de Texto de frecuencia máxima.
        self.lineEdit_4.setEnabled(False)           # Desactiva la caja de Texto de NFFT.
        self.lineEdit_5.setEnabled(False)           # Desactiva la caja de Texto de overlap.
        self.lineEdit_6.setEnabled(False)           # Desactiva la caja de Texto de Orden del Filter
        self.lineEdit_7.setEnabled(False)           # Desactiva la caja de texto de Fs
        self.lineEdit_8.setEnabled(False)           # Desactiva la caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setEnabled(False)           # Desactiva la caja de texto de Nº de Traza st[0].

        # Coloca el mensaje de las estadistica como al inicio
        self.label_9.setText("<html><head/><body><p align=\"justify\"><span style=\" font-size:7pt;\">Registry Statistics are:</span></p></body></html>")

        self.pushButton_6.setEnabled(False)   # Desactiva el boton de Graficar para el Análisis espectral
        # Cambia el texto en las etiquetas para Frecuencia mínima y máxima
        self.label_5.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Min Freq. (Hz):</span></p></body></html>")
        self.label_6.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Max Freq. (Hz):</span></p></body></html>")

        # Cambia el texto en la etiqueta para presentar de nuevo Frecuencia del Filter
        self.label_4.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Filter Freq. (Hz):</span></p></body></html>")

        self.lineEdit_8.setVisible(False)           # Oculta la caja de texto para los coeficientes discretos Wavelets

        plt.close()                                 # Close the existing chart.


    def activacion5(self):                          # To Enable / Disable and cleaning in Spectrogram

        plt.close()                                 # Close the existing chart.

        # Borrar el contenido de las cajas de texto y etiquetas
        self.lineEdit.setText("")                   # Borra contenido de caja de texto de Frecuencia
        self.lineEdit_2.setText("")                 # Borra contenido de caja de texto de frecuencia mínima
        self.lineEdit_3.setText("")                 # Borra contenido de caja de texto de frecuencia máxima
        self.lineEdit_6.setText("4")                # Inicia contenido de caja de texto de Orden de filtro = 4.
        self.lineEdit_8.setText("")                 # Borra contenido de caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setText("0")                # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.textEdit.setText("")                   # Borra contenido de la caja de texto de Metadatos
        self.textEdit_2.setText("")                 # Borra el contenido de la caja de texto de Trazas

        # Desactivar las cajas de texto y etiquetas que no se utilicen
        self.lineEdit.setEnabled(False)             # caja de texto de Frecuencia
        self.lineEdit_2.setEnabled(False)           # caja de texto de Frecuencia Mín.
        self.lineEdit_3.setEnabled(False)           # caja de texto de Frecuencia Máx.
        self.lineEdit_6.setEnabled(False)           # caja de texto de Orden del Filter
        self.lineEdit_4.setEnabled(True)            # Etiqueta de NFFT
        self.lineEdit_5.setEnabled(True)            # Etiqueta de Overlap
        self.lineEdit_7.setEnabled(True)            # Caja de texto de Fs
        self.lineEdit_8.setEnabled(False)           # Desactiva la caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setEnabled(True)            # Activa la caja de texto de Nº de Traza st[0].

        # Cambia el texto en las etiquetas para Frecuencia mínima y máxima
        self.label_5.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Min Freq. (Hz):</span></p></body></html>")
        self.label_6.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Max Freq. (Hz):</span></p></body></html>")

        # Cambia el texto en la etiqueta para presentar de nuevo Frecuencia del Filter
        self.label_4.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Filter Freq. (Hz):</span></p></body></html>")

        self.lineEdit_8.setVisible(False)           # Hides the text box for Discrete Wavelets coefficients.

        plt.close()                                 # Close the existing chart.

    def activacion6(self):                          # To Enable / Disable and cleaning in Envelope.

        plt.close()                                 # Close the existing chart.

        # Borrar el contenido de las cajas de texto y etiquetas
        self.lineEdit.setText("")                   # Borra contenido de caja de texto de Frecuencia
        self.lineEdit_2.setText("")                 # Borra contenido de caja de texto de frecuencia mínima
        self.lineEdit_3.setText("")                 # Borra contenido de caja de texto de frecuencia máxima
        self.lineEdit_4.setText("")                 # Borra contenido de la caja de texto de NFFT.
        self.lineEdit_5.setText("")                 # Borra contenido de la caja de texto de overlap.
        self.lineEdit_6.setText("4")                # Inicia contenido de caja de texto de Orden de filtro = 4.
        self.lineEdit_7.setText("")                 # Borra contenido de caja de texto de Fs.
        self.lineEdit_8.setText("")                 # Borra contenido de caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setText("0")                # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.textEdit.setText("")                   # Borra contenido de la caja de texto de Metadatos
        self.textEdit_2.setText("")                 # Borra el contenido de la caja de texto de Trazas

        # Desactivar las cajas de texto y etiquetas que no se utilicen
        self.lineEdit.setEnabled(True)              # Activa la caja de texto de Frecuencia
        self.lineEdit_2.setEnabled(True)            # Activa la caja de texto de Frecuencia Mín.
        self.lineEdit_3.setEnabled(True)            # Activa la caja de texto de Frecuencia Máx.
        self.lineEdit_6.setEnabled(True)            # Activa la caja de texto de Orden del Filter
        self.lineEdit_4.setEnabled(False)           # Desactiva la caja de texto de NFFT
        self.lineEdit_5.setEnabled(False)           # Desactiva la Etiqueta de Overlap
        self.lineEdit_7.setEnabled(False)           # Desactiva la Caja de texto de Fs
        self.lineEdit_8.setEnabled(False)           # Desactiva la caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setEnabled(True)            # Activa la caja de texto de Nº de Traza st[0].

        # Cambia el texto en las etiquetas para Time mínimo y máximo
        self.label_5.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#060776;\">T. Min (s):</span></p></body></html>")
        self.label_6.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#060776;\">T. Max (s):</span></p></body></html>")

        # Cambia el texto en la etiqueta para presentar de nuevo Frecuencia del Filter
        self.label_4.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Filter Freq. (Hz):</span></p></body></html>")

        self.lineEdit_8.setVisible(False)           # Hides the text box for Discrete Wavelets coefficients

        plt.close()                                 # Close the existing chart.

    def activacion7(self):                          # To Enable / Disable and cleaning in Continuous Wavelet Transform (CWT)

        plt.close()                                 # Close the existing chart.

        # Borrar el contenido de las cajas de texto y etiquetas
        self.lineEdit.setText("")                   # Borra contenido de caja de texto de Frecuencia.
        self.lineEdit_2.setText("")                 # Borra contenido de caja de texto de frecuencia mínima.
        self.lineEdit_3.setText("")                 # Borra contenido de caja de texto de frecuencia máxima.
        self.lineEdit_4.setText("")                 # Borra contenido de la caja de texto de NFFT.
        self.lineEdit_5.setText("")                 # Borra contenido de la caja de texto de overlap.
        self.lineEdit_6.setText("4")                # Inicia contenido de caja de texto de Orden de filtro = 4.
        self.lineEdit_7.setText("")                 # Borra contenido de caja de texto de Fs.
        self.lineEdit_8.setText("")                 # Borra contenido de caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setText("0")                # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.textEdit.setText("")                   # Borra contenido de la caja de texto de Metadatos
        self.textEdit_2.setText("")                 # Borra el contenido de la caja de texto de Trazas

        # Desactivar las cajas de texto y etiquetas que no se utilicen
        self.lineEdit.setEnabled(False)             # Desactiva la caja de texto de Frecuencia
        self.lineEdit_2.setEnabled(True)            # Activa la caja de texto de Frecuencia Mín.
        self.lineEdit_3.setEnabled(True)            # Activa la caja de texto de Frecuencia Máx.
        self.lineEdit_6.setEnabled(False)           # Desactiva la caja de texto de Orden del Filter
        self.lineEdit_4.setEnabled(False)           # Desactiva la Etiqueta de NFFT
        self.lineEdit_5.setEnabled(False)           # Desactiva la Etiqueta de Overlap
        self.lineEdit_7.setEnabled(False)           # Desactiva la Caja de texto de Fs
        self.lineEdit_8.setEnabled(False)           # Desactiva la caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setEnabled(True)            # Activa la caja de texto de Nº de Traza st[0].

        # Cambia el texto en las etiquetas para Frecuencia mínima y máxima
        self.label_5.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Min Freq. (Hz):</span></p></body></html>")
        self.label_6.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Max Freq. (Hz):</span></p></body></html>")

        # Cambia el texto en la etiqueta para presentar de nuevo Frecuencia del Filter
        self.label_4.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Filter Freq. (Hz):</span></p></body></html>")

        self.lineEdit_8.setVisible(False)           # Hides the text box for Discrete Wavelets coefficients

        plt.close()                                 # Close the existing chart.

    def activacion8(self):                          # To Activate / Deactivate and Clean, in the Discrete Coefficients Wavelets

        plt.close()                                 # Close the existing chart.

        # Limpiar entradas
        self.lineEdit.setText("")                   # Borra contenido de caja de texto de Frecuencia.
        self.lineEdit_2.setText("")                 # Borra contenido de caja de texto de frecuencia mínima.
        self.lineEdit_3.setText("")                 # Borra contenido de caja de texto de frecuencia máxima.
        self.lineEdit_4.setText("")                 # Borra contenido de la caja de texto de NFFT.
        self.lineEdit_5.setText("")                 # Borra contenido de la caja de texto de overlap.
        self.lineEdit_6.setText("4")                # Inicia contenido de caja de texto de Orden de filtro = 4.
        self.lineEdit_7.setText("")                 # Borra contenido de caja de texto de Fs.
        self.lineEdit_8.setText("")                 # Borra contenido de caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setText("0")                # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.textEdit.setText("")                   # Borra contenido de la caja de texto de Metadatos
        self.textEdit_2.setText("")                 # Borra el contenido de la caja de texto de Trazas

        # Habilitar y desabilitar cajas de texto de entradas.
        self.lineEdit.setEnabled(False)             # Desactiva la caja de Texto de Frecuencia.
        self.lineEdit_2.setEnabled(False)           # Desactiva la caja de Texto de frecuencia mínima.
        self.lineEdit_3.setEnabled(False)           # Desactiva la caja de Texto de frecuencia máxima.
        self.lineEdit_4.setEnabled(False)           # Desactiva la caja de Texto de NFFT.
        self.lineEdit_5.setEnabled(False)           # Desactiva la caja de Texto de overlap.
        self.lineEdit_6.setEnabled(False)           # Desactiva la caja de Texto de Orden del Filter
        self.lineEdit_7.setEnabled(False)           # Desactiva la caja de texto de Fs
        self.lineEdit_8.setEnabled(True)            # Activa la caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setEnabled(True)            # Activa la caja de texto de Nº de Traza st[0].

        # Cambia el texto en las etiquetas para Frecuencia mínima y máxima
        self.label_5.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Min Freq. (Hz):</span></p></body></html>")
        self.label_6.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Max Freq. (Hz):</span></p></body></html>")

        # Cambia el valor de la etiqueta para presentar el cuadro de texto que introduce el tipo de Coeficiente Wavelet discreto.
        self.label_4.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#060776;\">Discreet Coef. Type:</span></p></body></html>")

        self.lineEdit_8.setVisible(True)            # Activa la caja de texto para los coeficientes discretos Wavelets

        plt.close()                                 # Close the existing chart.

        # Wavelet Discrete Coefficients
        Text1 = (" --- Discrete Wavelet Coefficients types, that can be used for Calculation ---- \n"
            "\n"
            "'bior1.1' , 'bior1.3' , 'bior1.5' , 'bior2.2' , 'bior2.4' , 'bior2.6' , 'bior2.8' , 'bior3.1'\n"
            "'bior3.3' , 'bior3.5' , 'bior3.7' , 'bior3.9' , 'bior4.4' , 'bior5.5' , 'bior6.8' , 'coif1'\n"
            "'coif2' , 'coif3' , 'coif4' , 'coif5' , 'coif6' , 'coif7' , 'coif8' , 'coif9' , 'coif10' , 'coif11'\n"
            "'coif12' , 'coif13' , 'coif14' , 'coif15' , 'coif16' , 'coif17' , 'db1' , 'db2' , 'db3' , 'db4' , 'db5'\n"
            "'db6' , 'db7' , 'db8' , 'db9' , 'db10' , 'db11' , 'db12' , 'db13' , 'db14' , 'db15' , 'db16' , 'db17' , 'db18'\n"
            "'db19' , 'db20' , 'db21' , 'db22' , 'db23' , 'db24' , 'db25' , 'db26' , 'db27' , 'db28' , 'db29' , 'db30'\n"
            "'db31' , 'db32' , 'db33' , 'db34' , 'db35' , 'db36' , 'db37' 'db38' , 'dmey' , 'haar' 'rbio1.1'\n"
            "'rbio1.3' , 'rbio1.5' , 'rbio2.2' , 'rbio2.4' , 'rbio2.6' , 'rbio2.8' , 'rbio3.1' , 'rbio3.3'\n"
            "'rbio3.5' , 'rbio3.7' , 'rbio3.9' , 'rbio4.4' , 'rbio5.5' , 'rbio6.8' , 'sym2' , 'sym3' 'sym4'\n"
            "'sym5' , 'sym6' 'sym7' , 'sym8' , 'sym9' 'sym10' , 'sym11' , 'sym12' , 'sym13' , 'sym14'\n"
            "'sym15' , 'sym16' 'sym17' , 'sym18' , 'sym19' , 'sym20'\n"
            "\n"
            "NOTE: You can type, or copy and paste [without the quotes], the name you want to use in the text box above")

        self.textEdit.setText(Text1)                # Place the Wavelet Discrete Coefficients information in the text box.

    def activacion9(self):                          # To Activate / Deactivate and cleaning in the Spectrogram

        plt.close()                                 # Close the existing chart.

        # Limpiar entradas
        self.lineEdit.setText("")                   # Borra contenido de caja de texto de Frecuencia.
        self.lineEdit_2.setText("")                 # Borra contenido de caja de texto de frecuencia mínima.
        self.lineEdit_3.setText("")                 # Borra contenido de caja de texto de frecuencia máxima.
        self.lineEdit_4.setText("")                 # Borra contenido de la caja de texto de NFFT.
        self.lineEdit_5.setText("")                 # Borra contenido de la caja de texto de overlap.
        self.lineEdit_6.setText("4")                # Inicia contenido de caja de texto de Orden de filtro = 4.
        self.lineEdit_7.setText("")                 # Borra contenido de caja de texto de Fs.
        self.lineEdit_8.setText("")                 # Borra contenido de caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setText("0")                # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.textEdit.setText("")                   # Borra contenido de la caja de texto de Metadatos
        self.textEdit_2.setText("")                 # Borra el contenido de la caja de texto de Trazas

        # Habilitar y desabilitar cajas de texto de entradas
        self.lineEdit.setEnabled(False)             # Desactiva la caja de Texto de Frecuencia.
        self.lineEdit_2.setEnabled(False)           # Desactiva la caja de Texto de frecuencia mínima.
        self.lineEdit_3.setEnabled(False)           # Desactiva la caja de Texto de frecuencia máxima.
        self.lineEdit_4.setEnabled(False)           # Desactiva la caja de Texto de NFFT.
        self.lineEdit_5.setEnabled(False)           # Desactiva la caja de Texto de overlap.
        self.lineEdit_6.setEnabled(False)           # Desactiva la caja de Texto de Orden del Filter
        self.lineEdit_7.setEnabled(False)           # Desactiva la caja de texto de Fs
        self.lineEdit_8.setEnabled(False)           # Desactiva la caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setEnabled(True)            # Activa la caja de texto de Nº de Traza st[0].

        # Cambia el texto en las etiquetas para Frecuencia mínima y máxima
        self.label_5.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Min Freq. (Hz):</span></p></body></html>")
        self.label_6.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Max Freq. (Hz):</span></p></body></html>")

        # Cambia el texto en la etiqueta para presentar de nuevo Frecuencia del Filter
        self.label_4.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Filter Freq. (Hz):</span></p></body></html>")

        self.lineEdit_8.setVisible(False)           # Oculta la caja de texto para los coeficientes discretos Wavelets

        plt.close()                                 # Close the existing chart.

    def activacion10(self):                         # Para Activar/Desactivar y limpieza en Espectrograma con la Señal Filtrada, Filtro Paso-Banda

        plt.close()                                 # Close the existing chart.

        # Borrar el contenido de las cajas de texto y etiquetas
        self.lineEdit.setText("")                   # Borra contenido de caja de texto de Frecuencia
        self.lineEdit_2.setText("")                 # Borra contenido de caja de texto de frecuencia mínima
        self.lineEdit_3.setText("")                 # Borra contenido de caja de texto de frecuencia máxima
        self.lineEdit_6.setText("4")                # Inicia contenido de caja de texto de Orden de filtro = 4.
        self.lineEdit_8.setText("")                 # Borra contenido de caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setText("0")                # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.textEdit.setText("")                   # Borra contenido de la caja de texto de Metadatos
        self.textEdit_2.setText("")                 # Borra el contenido de la caja de texto de Trazas

        # Desactivar las cajas de texto y etiquetas que no se utilicen
        self.lineEdit.setEnabled(False)             # caja de texto de Frecuencia
        self.lineEdit_2.setEnabled(True)            # caja de texto de Frecuencia Mín.
        self.lineEdit_3.setEnabled(True)            # caja de texto de Frecuencia Máx.
        self.lineEdit_6.setEnabled(True)            # caja de texto de Orden del Filtro
        self.lineEdit_4.setEnabled(True)            # Etiqueta de NFFT
        self.lineEdit_5.setEnabled(True)            # Etiqueta de Overlap
        self.lineEdit_7.setEnabled(True)            # Caja de texto de Fs
        self.lineEdit_8.setEnabled(False)           # Desactiva la caja de texto de coeficientes discretos Wavelets.
        self.lineEdit_9.setEnabled(True)            # Activa la caja de texto de Nº de Traza st[0].

        # Cambia el texto en las etiquetas para Frecuencia mínima y máxima
        self.label_5.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Min (Hz):</span></p></body></html>")
        self.label_6.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Max (Hz):</span></p></body></html>")

        # Cambia el texto en la etiqueta para presentar de nuevo Frecuencia del Filtro
        self.label_4.setText("<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec. del Filtro (Hz):</span></p></body></html>")

        self.lineEdit_8.setVisible(False)           # Oculta la caja de texto para los coeficientes discretos Wavelets

        plt.close()                                 # Close the existing chart.

    """  *** Functions to perform analysis with filters (1-4) ***     """

    def filtropasobajo(self):                                               # 1.- Function to execute the Lowpass filter

        try:

            # Verify that the Frequency text box is not empty
            if not self.lineEdit.text():
                MensCombo1 = QMessageBox()
                MensCombo1.setIcon(QMessageBox.Warning)
                MensCombo1.setWindowTitle("Empty Frequency")
                MensCombo1.setText("Please, enter a valid Value")
                returnValue = MensCombo1.exec()

            elif not self.lineEdit_6.text():
                MensCombo2 = QMessageBox()
                MensCombo2.setIcon(QMessageBox.Warning)
                MensCombo2.setWindowTitle("Empty Filter Order")
                MensCombo2.setText("Please, enter a valid Value")
                returnValue = MensCombo2.exec()

            elif not self.lineEdit_9.text():
                MensCombo3 = QMessageBox()
                MensCombo3.setIcon(QMessageBox.Warning)
                MensCombo3.setWindowTitle("Trace No. Empty")
                MensCombo3.setText("Please, enter a valid Value")
                returnValue = MensCombo3.exec()

            else:
                # Filtering with a lowpass.
                plt.close()                                                 # Close the existing chart.
                self.label_9.setText("")                                    # Borra contenido de caja de texto de estadistica del registro
                self.textEdit.setText("")                                   # Borra contenido de la caja de texto de Metadatos

                self.lineEdit_4.setText("")                                 # Borra contenido de caja de texto de NFTT
                self.lineEdit_5.setText("")                                 # Borra contenido de caja de texto de Noverlap

                self.lineEdit_4.setEnabled(False)                           # caja de texto de NFTT
                self.lineEdit_5.setEnabled(False)                           # caja de texto de Noverlap

                archivoFil1 = (self.label_2.text())                         # Lectura etiqueta del Record

                head, tail = os.path.split(self.archivo_abierto)
                root, extension = os.path.splitext(self.archivo_abierto)
                root, extension = os.path.splitext(tail)

                frec1 = (self.lineEdit.text())                              # Lectura etiqueta de la Frecuencia
                orden1 = (self.lineEdit_6.text())                           # Lectura del orden del Filter

                st  = obspy.read(archivoFil1)                               # Lectura archivo de acuerdo al formato

                # Convertir a flotante el valor string de la caja de texto
                frec2=float(frec1)                                          # Convierte el valor de Frecuencia a flotante
                orden2=int(orden1)                                          # Convierte el valor del orden del filtro a entero

                # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                NTraza = (self.lineEdit_9.text())                           # Lectura del contenido de la caja de texto Nº Traza st[0]
                Ntraza2 = int(NTraza)                                       # Convierte el valor del Nº de Traza a entero
                tr = st[Ntraza2]                                            # Asigna el número de traza indicado al Stream para tratamiento del registro

                tr.stats.station
                tr_filt = tr.copy()
                s = len(tr)
                tr_filt.filter('lowpass', freq=frec2, corners=orden2, zerophase=True)
                # Donde corners = orden del filtro, de orden 2

                t = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)

                ax = plt.subplot(211)

                plt.plot(t, tr.data, 'k', label='Original Record')          # Donde 'k' es el color = black
                plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda

                #plt.ylabel('Record - Amplitude', color ="blue")
                plt.ylabel('Record - Amplitude', color ="blue")
                plt.grid()
                plt.subplot(212, sharex=ax)
                plt.plot(t, tr_filt.data, 'b', label='Filtered Record')     # b = color, azul
                plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                # color para plor: k=black, r=red, b=blue,
                # lineas-> : = estilo de línea punteada, -- = estilo de línea discontinua


                #plt.ylabel('Filtered data Lowpassed', color ="blue")
                plt.xlabel('Time [s]', color ="red")
                plt.title(u'Filtered Record - Lowpass', color ="darkgreen")  # Ponemos un título
                plt.suptitle("Record : %s " % tr.stats.starttime, color ="red")
                plt.grid()                                                   # presenta la cuadricula en el grafico
                plt.show()

                # Seismic record statistics calculations
                datos = tr.data
                # Calculate the arithmetic mean
                Ftr = datos.mean()
                # Calculate the median
                FMed = np.median(datos)
                # Calculate the standard deviation
                DT = np.std(datos)
                # Calculate the variance
                VAR = np.var(datos)

                # Record Statistics Printing
                msg_e1 = "%s %s %s %s %s %s %s %s %s %s %s %s %s %s" % (" The arithmetic mean is: ", Ftr, " | The median is: ", FMed,
                         " | The standard deviation is: ", DT, " | The variance is: ", VAR,
                         "| The fs  (Hz) is:", tr.stats.sampling_rate, "| The Number of Samples is: ", tr.stats.npts, "| The Format is :", tr.stats._format)


                msg_e2 = "%s" % (tr.stats)                                  # To present the metadata

                stream = Stream(traces=[st])                                # Para presentar el numero de trazas total
                A5 = (Stream.__str__(st, extended=True))                    # Variable que contiene el numero total de trazas del registro
                mg3 = "%s" %(A5)                                            # convertir a string o texto los datos de las trazas

                # Formato de Texto
                font=QtGui.QFont()
                font.setFamily("Times New Roman")
                font.setPointSize(7)
                font.setBold(False)
                font.setItalic(False)
                font.setWeight(60)

                self.label_9.setFont(font)                                  # Impresion mediante el formato de texto
                self.label_9.setText(msg_e1)                                # Impresión en la eiqueta de la estadistica del Record

                self.textEdit.setText(msg_e2)                               # Coloca la información de Metadatos en el cuadro de texto 1
                self.textEdit_2.setText(mg3)                                # Coloca la información del Nº de Trazas en el cuadro de texto 2

        except:
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Input or Record File")
                returnValue = msgBox.exec()
                pass


    def filtropasoalto(self):                                               # 2.- Function to execute the Highpass filter

        try:

            # Verify that the Frequency text box is not empty
            if not self.lineEdit.text():
                MensCombo1 = QMessageBox()
                MensCombo1.setIcon(QMessageBox.Warning)
                MensCombo1.setWindowTitle("Frecuencia Vacio")
                MensCombo1.setText("Please, enter a valid Value")
                returnValue = MensCombo1.exec()

            elif not self.lineEdit_6.text():
                MensCombo2 = QMessageBox()
                MensCombo2.setIcon(QMessageBox.Warning)
                MensCombo2.setWindowTitle("Empty Filter Order")
                MensCombo2.setText("Please, enter a valid Value")
                returnValue = MensCombo2.exec()

            elif not self.lineEdit_9.text():
                MensCombo3 = QMessageBox()
                MensCombo3.setIcon(QMessageBox.Warning)
                MensCombo3.setWindowTitle("Trace No. Empty")
                MensCombo3.setText("Please, enter a valid Value")
                returnValue = MensCombo3.exec()

            else:
                # Filtering with a highpass.
                plt.close()                                                 # Close the existing chart.

                archivoFil1 = (self.label_2.text())                         # Lectura etiqueta del Record
                frec3 = (self.lineEdit.text())                              # Lectura etiqueta de la Frecuencia
                orden3 = (self.lineEdit_6.text())                           # Lectura del orden del Filter
                # Convertir a flotante el valor string de la caja de texto
                frec4=float(frec3)                                          # Convierte el valor de Frecuencia a flotante
                orden4=int(orden3)                                          # Convierte el valor del orden del filtro a entero
                st  = obspy.read(archivoFil1)                               # Lectura archivo de acuerdo al formato

                # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                NTraza = (self.lineEdit_9.text())                           # Lectura del contenido de la caja de texto Nº Traza st[0]
                Ntraza2 = int(NTraza)                                       # Convierte el valor del Nº de Traza a entero
                tr = st[Ntraza2]                                            # Asigna el número de traza indicado al Stream para tratamiento del registro

                tr.stats.station

                # Where corners = filter order - order 4

                t = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)

                tr.data = np.where(tr.data==min(tr.data),0,tr.data)

                tr_filt = tr.copy()
                tr_filt.filter('highpass', freq=frec4, corners=orden4, zerophase=True)

                ax = plt.subplot(211)
                plt.plot(t, tr.data, 'darkgreen', label='Original Record ')         # Where 'k' is the color = black

                plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left
                plt.ylabel('Record - Amplitude', color ="blue")
                plt.grid()
                plt.subplot(212, sharex=ax)

                plt.plot(t,tr_filt.data, 'b', label='Filtered Record ')         # Where 'k' is the color = black
                plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left
                plt.ylabel('Filtered data Highpass', color ="blue")
                plt.xlabel('Time [s]', color ="red")
                plt.title(u'Filtered Record - Highpass', color ="darkgreen")  # We put a title
                plt.suptitle("Record: %s " % tr.stats.starttime, color ="red")
                plt.grid()                                                  # Shows the grid on the graph

                #plt.savefig('Grafica1_Ejemplo.pgf')

                plt.show()



                # Seismic record statistics calculations
                datos = tr.data
                # Calculate the arithmetic mean
                Ftr = datos.mean()
                # Calculate the median
                FMed = np.median(datos)
                # Calculate the standard deviation
                DT = np.std(datos)
                # Calculate the variance
                VAR = np.var(datos)

                # Record Statistics Printing
                msg_e1 = "%s %s %s %s %s %s %s %s %s %s %s %s %s %s" % (" The arithmetic mean is: ", Ftr, " | The median is: ", FMed,
                         " | The standard deviation is: ", DT, " | The variance is: ", VAR,
                         "| The fs  (Hz) is:", tr.stats.sampling_rate, "| The Number of Samples is: ", tr.stats.npts, "| The Format is :", tr.stats._format)

                msg_e2 = "%s" % (tr.stats)                                  # To present the metadata

                stream = Stream(traces=[st])                                # Para presentar el numero de trazas total
                A5 = (Stream.__str__(st, extended=True))                    # Variable que contiene el numero total de trazas del registro
                mg3 = "%s" %(A5)                                            # convertir a string o texto los datos de las trazas

                font=QtGui.QFont()
                font.setFamily("Times New Roman")
                font.setPointSize(8)
                font.setBold(False)
                font.setItalic(False)
                font.setWeight(60)

                self.label_9.setFont(font)                                  # Impresion mediante el formato de texto
                self.label_9.setText(msg_e1)                                # Impresión en la eiqueta de la estadistica del Record

                self.textEdit.setText(msg_e2)                               # Coloca la información de Metadatos en el cuadro de texto 1
                self.textEdit_2.setText(mg3)                                # Coloca la información del Nº de Trazas en el cuadro de texto 2
        except:
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Input or Record File")
                returnValue = msgBox.exec()

    def filtropasabanda(self):                                              # 3.- Function to execute the Bandpass filter

        try:

            # Verify that the text boxes of the Minimum, Maximum Frequencies and filter order are not empty
            if not self.lineEdit_2.text():
                MensCombo1 = QMessageBox()
                MensCombo1.setIcon(QMessageBox.Warning)
                MensCombo1.setWindowTitle("Empty Frequency Min.")
                MensCombo1.setText("Please, enter a valid Value")
                returnValue = MensCombo1.exec()

            elif not self.lineEdit_3.text():
                MensCombo2 = QMessageBox()
                MensCombo2.setIcon(QMessageBox.Warning)
                MensCombo2.setWindowTitle("Empty Frequency Max.")
                MensCombo2.setText("Please, enter a valid Value")
                returnValue = MensCombo2.exec()

            elif not self.lineEdit_6.text():
                MensCombo3 = QMessageBox()
                MensCombo3.setIcon(QMessageBox.Warning)
                MensCombo3.setWindowTitle("Empty Filter Order")
                MensCombo3.setText("Please, enter a valid Value")
                returnValue = MensCombo3.exec()

            elif not self.lineEdit_9.text():
                MensCombo4 = QMessageBox()
                MensCombo4.setIcon(QMessageBox.Warning)
                MensCombo4.setWindowTitle("Trace No. Empty")
                MensCombo4.setText("Please, enter a valid Value")
                returnValue = MensCombo4.exec()

            else:
                # Filtering with a bandpass
                plt.close()                                                 # Close the existing chart.

                archivoFil1 = (self.label_2.text())                         # Lectura etiqueta del Record
                frecM = (self.lineEdit_2.text())                            # Lectura etiqueta de Frec. Min.
                frecMax = (self.lineEdit_3.text())                          # Lectura etiqueta de Frec. Max.
                orden6 = (self.lineEdit_6.text())                           # Lectira del orden del filtro

                # Convertir a flotante los valores string del texto de las cajas
                frec7=float(frecM)                                          # Convierte a flotante el valor de la Frec. Min.
                frec8=float(frecMax)                                        # Convierte a flotante el valor de la Frec. Max.
                orden7=int(orden6)                                          # Convierte a entero el valor del orden del filtro

                st  = obspy.read(archivoFil1)                               # Lectura archivo de acuerdo al formato

                # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                NTraza = (self.lineEdit_9.text())                           # Lectura del contenido de la caja de texto Nº Traza st[0]
                Ntraza2 = int(NTraza)                                       # Convierte el valor del Nº de Traza a entero
                tr = st[Ntraza2]                                            # Asigna el número de traza indicado al Stream para tratamiento del registro

                tr.stats.station
                tr_filt = tr.copy()

                tr_filt.filter('bandpass', freqmin=frec7, freqmax=frec8, corners=orden7, zerophase=True)
                # Donde corners = orden del filtro

                npts = st[0].stats.npts
                # Vector de Time
                t = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)

                ax = plt.subplot(211)
                plt.plot(t, tr.data, 'k', label='Original Record')              # Where 'k' is the color = black
                plt.legend(prop = {'size': 10}, loc='upper right')              # Para colocar la leyenda a la izquierda

                plt.ylabel('Record - Amplitude', color ="blue")
                plt.grid()
                plt.subplot(212, sharex=ax)
                plt.plot(t, tr_filt.data, 'b', label='Filtered Record')
                plt.legend(prop = {'size': 10}, loc='upper right')              # Para colocar la leyenda a la izquierda
                plt.ylabel('Filtered data Bandpass', color ="blue")
                plt.xlabel('Time [s]', color = "red")
                plt.title(u'Filtered Record - Bandpass', color ="darkgreen")    # Ponemos un título
                plt.suptitle("Record: %s " % tr.stats.starttime, color ="red")
                plt.grid()                                                      # presenta la cuadricula en el grafico
                plt.show()

                # Seismic record statistics calculations
                datos = tr.data
                # Calculate the arithmetic mean
                Ftr = datos.mean()
                # Calculate the median
                FMed = np.median(datos)
                # Calculate the standard deviation
                DT = np.std(datos)
                # Calculate the variance
                VAR = np.var(datos)

                # Record Statistics Printing
                msg_e1 = "%s %s %s %s %s %s %s %s %s %s %s %s %s %s" % (" The arithmetic mean is: ", Ftr, " | The median is: ", FMed,
                         " | The standard deviation is: ", DT, " | The variance is: ", VAR,
                         "| The fs  (Hz) is:", tr.stats.sampling_rate, "| The Number of Samples is: ", tr.stats.npts, "| The Format is :", tr.stats._format)

                msg_e2 = "%s" % (tr.stats)                                  # To present the metadata

                stream = Stream(traces=[st])                                # Para presentar el numero de trazas total
                A5 = (Stream.__str__(st, extended=True))                    # Variable que contiene el numero total de trazas del registro
                mg3 = "%s" %(A5)                                            # convertir a string o texto los datos de las trazas

                font=QtGui.QFont()
                font.setFamily("Times New Roman")
                font.setPointSize(7)
                font.setBold(False)
                font.setItalic(False)
                font.setWeight(60)

                self.label_9.setFont(font)                                  # Impresion mediante el formato de texto
                self.label_9.setText(msg_e1)                                # Impresión en la eiqueta de la estadistica del Record

                self.textEdit.setText(msg_e2)                               # Coloca la información de Metadatos en el cuadro de texto 1
                self.textEdit_2.setText(mg3)                                # Coloca la información del Nº de Trazas en el cuadro de texto 2
        except:
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Input or Record File")
                returnValue = msgBox.exec()

    def filtrobandstop(self):                                               # 4.- Function to execute the Stopband filter.

        try:

            # Verify that the text boxes are not empty
            if not self.lineEdit_2.text():
                MensCombo1 = QMessageBox()
                MensCombo1.setIcon(QMessageBox.Warning)
                MensCombo1.setWindowTitle("Frec. Min. Vacio")
                MensCombo1.setText("Please, enter a valid Value")
                returnValue = MensCombo1.exec()

            elif not self.lineEdit_3.text():
                MensCombo2 = QMessageBox()
                MensCombo2.setIcon(QMessageBox.Warning)
                MensCombo2.setWindowTitle("Frec. Max. Vacio")
                MensCombo2.setText("Please, enter a valid Value")
                returnValue = MensCombo2.exec()

            elif not self.lineEdit_6.text():
                MensCombo3 = QMessageBox()
                MensCombo3.setIcon(QMessageBox.Warning)
                MensCombo3.setWindowTitle("Empty Filter Order")
                MensCombo3.setText("Please, enter a valid Value")
                returnValue = MensCombo3.exec()

            elif not self.lineEdit_9.text():
                MensCombo4 = QMessageBox()
                MensCombo4.setIcon(QMessageBox.Warning)
                MensCombo4.setWindowTitle("Trace No. Empty")
                MensCombo4.setText("Please, enter a valid Value")
                returnValue = MensCombo4.exec()

            else:
                 # Filtrando con un bandstop en una copia de la traza original
                plt.close()  # cierra el gráfico existente

                archivoFil1 = (self.label_2.text())                         # Lectura etiqueta del Record
                frecM = (self.lineEdit_2.text())                            # Lectura etiqueta de Frec. Min.
                frecMax = (self.lineEdit_3.text())                          # Lectura etiqueta de Frec. Max.
                orden8 = (self.lineEdit_6.text())                           # Lectira del orden del filtro

                # Convertir a flotante los valores string del texto de las cajas
                frec9=float(frecM)                                          # Convierte a flotante el valor de entrada de Frecuencia Min.
                frec10=float(frecMax)                                       # Convierte a flotante el valor de entrada de Frecuencia Max.
                orden9=int(orden8)                                          # Convierte a entero el valor de entrada del orden del filtro.

                st  = obspy.read(archivoFil1)                               # Lectura archivo de acuerdo al formato

                # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                NTraza = (self.lineEdit_9.text())                           # Lectura del contenido de la caja de texto Nº Traza st[0]
                Ntraza2 = int(NTraza)                                       # Convierte el valor del Nº de Traza a entero
                tr = st[Ntraza2]                                            # Asigna el número de traza indicado al Stream para tratamiento del registro

                tr.stats.station
                tr_filt = tr.copy()

                tr_filt.filter('bandstop', freqmin=frec9, freqmax=frec10, corners=orden9, zerophase=True)
                # Donde corners = orden del filtro, de orden leida por 'orden9'

                npts = st[0].stats.npts
                # Vector de tiempo
                t = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)

                ax = plt.subplot(211)
                plt.plot(t, tr.data, 'k', label='Original Record')          # Where 'k' is the color = black
                plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda

                plt.ylabel('Record - Amplitude', color ="blue")
                plt.grid()
                plt.subplot(212, sharex=ax)
                plt.plot(t, tr_filt.data, 'b', label='Filtered Record')
                plt.legend(prop = {'size': 10}, loc='upper right')          # Para colocar la leyenda a la izquierda
                plt.ylabel('Filtered data Bandstop', color ="blue")
                plt.xlabel('Time [s]', color ="red")
                plt.title(u'Filtered Record - Stop-Banda', color ="darkgreen")  # Ponemos un título
                plt.suptitle("Record: %s " % tr.stats.starttime, color ="red")
                plt.grid()                                                  # presenta la cuadricula en el grafico
                plt.show()

                # Seismic record statistics calculations
                datos = tr.data
                # Calculate the arithmetic mean
                Ftr = datos.mean()
                # Calculate the median
                FMed = np.median(datos)
                # Calculate the standard deviation
                DT = np.std(datos)
                # Calculate the variance
                VAR = np.var(datos)

                # Record Statistics Printing
                msg_e1 = "%s %s %s %s %s %s %s %s %s %s %s %s %s %s" % (" The arithmetic mean is: ", Ftr, " | The median is: ", FMed,
                         " | The standard deviation is: ", DT, " | The variance is: ", VAR,
                         "| The fs  (Hz) is:", tr.stats.sampling_rate, "| The Number of Samples is: ", tr.stats.npts, "| The Format is :", tr.stats._format)

                msg_e2 = "%s" % (tr.stats)                                  # To present the metadata

                stream = Stream(traces=[st])                                # Para presentar el numero de trazas total
                A5 = (Stream.__str__(st, extended=True))                    # Variable que contiene el numero total de trazas del registro
                mg3 = "%s" %(A5)                                            # convertir a string o texto los datos de las trazas

                font=QtGui.QFont()
                font.setFamily("Times New Roman")
                font.setPointSize(8)
                font.setBold(False)
                font.setItalic(False)
                font.setWeight(60)

                self.label_9.setFont(font)                                  # Impresion mediante el formato de texto
                self.label_9.setText(msg_e1)                                # Impresión en la eiqueta de la estadistica del Record

                self.textEdit.setText(msg_e2)                               # Coloca la información de Metadatos en el cuadro de texto 1
                self.textEdit_2.setText(mg3)                                # Coloca la información del Nº de Trazas en el cuadro de texto 2
        except:
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Input or Record File")
                returnValue = msgBox.exec()

    """ Function, which loads the functions for analysis with filters   """

    def verificar(self):                                                    # Function to validate entries and plot Filters.

            index1 = self.comboBox_2.currentIndex()                         # Reading the ComboBox index.

            if (1 == index1):
                #print("Entrada a funcion Paso Bajo")
                self.filtropasobajo()                                       # Lowpass filter.
            elif (2 == index1):
                #print("Entrada a funcion Paso Alto")
                self.filtropasoalto()                                       # Highpass filter.
            elif (3 == index1):
                #print("Entrada a funcion Paso Banda")
                self.filtropasabanda()                                      # Bandpass filter.
            elif (4 == index1):
                #print("Entrada a funcion Stop Banda")
                self.filtrobandstop()                                       # Stopband filter.

            else:
                pass

    """ Function, which loads the functions for spectral analysis  """

    def editar(self):                                                       # Function to validate inputs and plot the Spectral Analysis.

            index3a = self.comboBox.currentIndex()

            if (1 == index3a):
                self.especfourier()         # Llamada a la función para construir el Espectro de Fourier en Frecuencia

            elif (2 == index3a):
                self.espectogram1()         # Llamada a la función para construir el espectrograma

            elif (3 == index3a):
                self.espectogram2()         # Llamada a la función para construir el espectrograma con señal filtrada

            elif (4 == index3a):
                self.envolver1()            # Llamada a la función para construir la Envolvente de la señal

            elif (5 == index3a):
                self.PWelch()               # Llamada a la función para construir la densidad espectral de potencia utilizando el método de Welch

            elif (6 == index3a):
                self.densidad1()            # Llamada a la función para construir el Periodograma clásico más cinco tipos de ventana Welch Espectral del Record

            elif (7== index3a):
                self.Twawelet1()            # Llamada a la función para construir la Transformada Wavelet Continua

            elif (8 == index3a):
                self.Coefici1()             # Llamada a la función para construir los Coeficientes Wavelets discretos

            else:
                pass  # Pasamos !!!

    """  *** Functions to perform spectral analysis (1-8) ***     """

    def especfourier(self):                                             # 1.- Function that allows to construct the Fourier spectrum

        try:

            if not self.lineEdit_9.text():
                MensCombo3 = QMessageBox()
                MensCombo3.setIcon(QMessageBox.Warning)
                MensCombo3.setWindowTitle("Trace No. Empty")
                MensCombo3.setText("Please, enter a valid Value")
                returnValue = MensCombo3.exec()

            else:

                plt.close()                                             # Close the existing chart.

                A2 = (self.label_2.text())                              # Lectura etiqueta del Record
                st  = obspy.read(A2)                                    # Lectura archivo de acuerdo al formato

                # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                NTraza = (self.lineEdit_9.text())                       # Lectura del contenido de la caja de texto Nº Traza st[0]
                Ntraza2 = int(NTraza)                                   # Convierte el valor del Nº de Traza a entero
                tr = st[Ntraza2]                                        # Asigna el número de traza indicado al Stream para tratamiento del registro

                tr.stats.station
                n = len(tr)                                             # longitud de la señal
                # Calculo del tiempo del registro
                t = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)

                # Lectura de a frecuencstreo
                samplingFrequency  = tr.stats.sampling_rate

                plt.subplot(311)
                plt.plot(t, tr.data, 'k', label='Original Record')      # Where 'k' is the color = black
                plt.legend(prop = {'size': 10}, loc='upper right')      # Para colocar la leyenda a la izquierda
                plt.title('Fourier transform (FFT), represents the frequency components', color ="green")

                plt.ylabel('Record - Amplitude', color ="blue")
                plt.xlabel('Time [s]', color ="red")
                plt.grid()

                # Grafico de la FFt en el dominio de lq Frecuencia
                plt.subplot(312)
                fourierTransform = np.fft.fft(tr.data)/n                        # fft calcula la normalizacion de la amplitud
                fourierTransform = fourierTransform[range(int(len(tr.data)/2))] # Excluir la frecuencia de muestreo
                # Valores a calcular
                tpCount     = n
                values      = np.arange(int(tpCount/2))
                timePeriod  = tpCount/samplingFrequency
                frequencies = values/timePeriod

                # Representation in the frequency domain
                plt.plot(frequencies, abs(fourierTransform), label='FFT Transform in Frequency')
                plt.legend(prop = {'size': 10}, loc='upper right')              # To place the legend on the left
                plt.suptitle("Record : %s " % tr.stats.starttime, color ="red")
                plt.ylabel('Register - Amplitude ', color ="blue")
                plt.grid()                                                  # Shows the grid on the graph

                # Logarithmic magnitude of the spectrum
                plt.subplot(313)
                plt.magnitude_spectrum(tr.data, samplingFrequency, scale='dB', color='#008080', label="Spectrum Logarithmic Magnitude")
                plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left
                plt.title('Frequency (Hz)', color ="red", size=10)
                plt.xlabel('Frequency (Hz)', color ="red")
                plt.ylabel('Magnitude (dB)', color ="blue")
                plt.grid()                                                  # Shows the grid on the graph

                # Magnitude in Phase of the spectrum
                plt.figure()
                plt.phase_spectrum(tr.data, samplingFrequency, color='navy', label="Spectrum Phase Magnitude")
                plt.legend(prop = {'size': 10}, loc='upper right')              # To place the legend on the left
                plt.title('Fourier transform (FFT), represents the frequency components', color ="green")
                plt.suptitle("Record : %s " % tr.stats.starttime, color ="red")
                plt.xlabel('Frequency (Hz)', color ="red")
                plt.ylabel('Phase (Radians)', color ="blue")
                plt.grid()                                                  # Shows the grid on the graph
                plt.show()

                # Seismic record statistics calculations
                datos = tr.data
                # Calculate the arithmetic mean
                Ftr = datos.mean()
                # Calculate the median
                FMed = np.median(datos)
                # Calculate the standard deviation
                DT = np.std(datos)
                # Calculate the variance
                VAR = np.var(datos)

                # Record Statistics Printing
                msg_e1 = "%s %s %s %s %s %s %s %s %s %s %s %s %s %s" % (" The arithmetic mean is: ", Ftr, " | The median is: ", FMed,
                         " | The standard deviation is: ", DT, " | The variance is: ", VAR,
                         "| The fs  (Hz) is:", tr.stats.sampling_rate, "| The Number of Samples is: ", tr.stats.npts, "| The Format is :", tr.stats._format)

                msg_e2 = "%s" % (tr.stats)

                stream = Stream(traces=[st])                                # Para presentar el numero de trazas total
                A5 = (Stream.__str__(st, extended=True))                    # Variable que contiene el numero total de trazas del registro
                mg3 = "%s" %(A5)                                            # convertir a string o texto los datos de las trazas

                # Formato para los valores del texto en las estadísticas y cuadro de texto
                font=QtGui.QFont()
                font.setFamily("Times New Roman")
                font.setPointSize(8)
                font.setBold(False)
                font.setItalic(False)
                font.setWeight(60)

                self.label_9.setFont(font)                                  # Impresion mediante el formato de texto
                self.label_9.setText(msg_e1)                                # Impresión en la eiqueta de la estadistica del Record
                self.textEdit.setText(msg_e2)                               # Coloca la información de Metadatos en el cuadro de texto
                self.textEdit_2.setText(mg3)                                # Coloca la información del Nº de Trazas en el cuadro de texto 2

        except:

                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Input or Record File")
                returnValue = msgBox.exec()

    def espectogram1(self):                                                 # 2.- Function that allows to build the Spectrogram

        try:
            # Verificar que la caja de texto de la Frecuencia no este vacía
            if not self.lineEdit_4.text():
                MensCombo1 = QMessageBox()
                MensCombo1.setIcon(QMessageBox.Warning)
                MensCombo1.setWindowTitle("Empty NFFT")
                MensCombo1.setText("Please, enter a valid Value")
                returnValue = MensCombo1.exec()

            elif not self.lineEdit_5.text():
                MensCombo2 = QMessageBox()
                MensCombo2.setIcon(QMessageBox.Warning)
                MensCombo2.setWindowTitle("Empty Overlap")
                MensCombo2.setText("Please, enter a valid Value")
                returnValue = MensCombo2.exec()

            elif not self.lineEdit_7.text():
                MensCombo3 = QMessageBox()
                MensCombo3.setIcon(QMessageBox.Warning)
                MensCombo3.setWindowTitle("Empty Fs")
                MensCombo3.setText("Please, enter a valid Value")
                returnValue = MensCombo3.exec()

            elif not self.lineEdit_9.text():
                MensCombo4 = QMessageBox()
                MensCombo4.setIcon(QMessageBox.Warning)
                MensCombo4.setWindowTitle("Trace No. Empty")
                MensCombo4.setText("Please, enter a valid Value")
                returnValue = MensCombo4.exec()

            else:
                # Filtrando con un lowpass en una copia de la traza original
                plt.close()  # cierra el gráfico existente

                #× Lectura del Record y etiquetas
                archivoFil2 = (self.label_2.text())                 # Lectura etiqueta del Record

                frec1 = (self.lineEdit_4.text())                    # Lectura etiqueta de la NFFT
                frec2 = (self.lineEdit_5.text())                    # Lectura etiqueta del noverlap
                frec3 = (self.lineEdit_7.text())                    # Lectura etiqueta de Fs

                # Convertir a entero los valores string de las cajas de texto
                frec4=int(frec1)                                    # Convierte el valor de NFFT
                frec5=int(frec2)                                    # Convierte el valor de overlap
                frec6=int(frec3)                                    # Convierte el valor de Fs

                st  = obspy.read(archivoFil2)  # Lectura archivo de acuerdo al formato


                # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                NTraza = (self.lineEdit_9.text())                   # Lectura del contenido de la caja de texto Nº Traza st[0]
                Ntraza2 = int(NTraza)                               # Convierte el valor del Nº de Traza a entero
                tr = st[Ntraza2]                                    # Asigna el número de traza indicado al Stream para tratamiento del registro

                tr_filt = tr.copy()

                tr_filt.filter('bandpass', freqmin=1.5, freqmax=25, corners=4, zerophase=True)


                tr.stats.station
                # Cálculo del valor del tiempo
                t = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)

                ax = plt.subplot(211)
                plt.plot(t, tr_filt.data, 'k', label='Original Record')          # Where 'k' it's the color = black
                plt.ylabel('Record amplitude', color ="blue")
                # legend takes the value of label in plot to render the legend
                plt.legend(prop = {'size': 10}, loc='upper right')
                plt.grid()                                                  # Shows the grid on the graph

                plt.subplot(212, sharex=ax)
                # color can be: (cmap="gray") -> gray  (cmap="jet") -> colors
                # mode can be: 'default', 'psd', 'magnitude', 'angle', 'phase'
                plt.specgram(tr_filt.data, NFFT=frec4, Fs=frec6, mode='magnitude', noverlap=frec5, cmap="jet")
                # Formato de los valores del espectrograma
                plt.ylabel('Frequency [Hz]', color ="blue")
                plt.xlabel('Time [s]', color ="red")
                plt.title(u'Spectrogram', color ="darkgreen" )  # We put a title
                plt.suptitle("Record: %s " % tr.stats.starttime, color ="red")
                plt.grid()                                                  # Shows the grid on the graph

                clb = plt.colorbar(orientation='horizontal')                # Colorbar format examples
                # Label format for spectrogram colormap.
                clb.set_label('Scale of Values in (%) of Energy, Spectrogram (Dark red = Higher %)', labelpad=5, y=1.05, rotation=0, fontsize=14, color ="blue")

                plt.show()

                # Seismic record statistics calculations
                datos = tr.data
                # Calculate the arithmetic mean
                Ftr = datos.mean()
                # Calculate the median
                FMed = np.median(datos)
                # Calculate the standard deviation
                DT = np.std(datos)
                # Calculate the variance
                VAR = np.var(datos)

                # Record Statistics Printing
                msg_e1 = "%s %s %s %s %s %s %s %s %s %s %s %s %s %s" % (" The arithmetic mean is: ", Ftr, " | The median is: ", FMed,
                         " | The standard deviation is: ", DT, " | The variance is: ", VAR,
                         "| The fs  (Hz) is:", tr.stats.sampling_rate, "| The Number of Samples is: ", tr.stats.npts, "| The Format is :", tr.stats._format)

                msg_e2 = "%s" % (tr.stats)

                stream = Stream(traces=[st])                                # Para presentar el numero de trazas total
                A5 = (Stream.__str__(st, extended=True))                    # Variable que contiene el numero total de trazas del registro
                mg3 = "%s" %(A5)                                            # convertir a string o texto los datos de las trazas

                # Formato para los valores del texto en las estadísticas y cuadro de texto
                font=QtGui.QFont()
                font.setFamily("Times New Roman")
                font.setPointSize(8)
                font.setBold(False)
                font.setItalic(False)
                font.setWeight(60)

                self.label_9.setFont(font)                                  # Impresion mediante el formato de texto
                self.label_9.setText(msg_e1)                                # Impresión en la eiqueta de la estadistica del Record
                self.textEdit.setText(msg_e2)                               # Coloca la información de Metadatos en el cuadro de texto
                self.textEdit_2.setText(mg3)                                # Coloca la información del Nº de Trazas en el cuadro de texto 2

        except:
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Input or Record File")
                returnValue = msgBox.exec()

    def espectogram2(self):   # 2.- Function that allows to build the Spectrogram with PassBand filter signal

        try:
            # Verificar que las cajas de texto del filtro no esten vacías

            if not self.lineEdit_2.text():
                MensCombo1 = QMessageBox()
                MensCombo1.setIcon(QMessageBox.Warning)
                MensCombo1.setWindowTitle("Frec. Min. Vacio")
                MensCombo1.setText("Ingrese un Valor válido")
                returnValue = MensCombo1.exec()

            elif not self.lineEdit_3.text():
                MensCombo2 = QMessageBox()
                MensCombo2.setIcon(QMessageBox.Warning)
                MensCombo2.setWindowTitle("Frec. Max. Vacio")
                MensCombo2.setText("Ingrese un Valor válido")
                returnValue = MensCombo2.exec()

            elif not self.lineEdit_6.text():
                MensCombo3 = QMessageBox()
                MensCombo3.setIcon(QMessageBox.Warning)
                MensCombo3.setWindowTitle("Orden Filtro Vacio")
                MensCombo3.setText("Ingrese un Valor válido")
                returnValue = MensCombo3.exec()

            # Verificar que las cajas de texto para los valores del espectrograma no esten vacías

            elif not self.lineEdit_4.text():
                MensCombo1 = QMessageBox()
                MensCombo1.setIcon(QMessageBox.Warning)
                MensCombo1.setWindowTitle("Valor NFFT Vacio")
                MensCombo1.setText("Ingrese un Valor válido")
                returnValue = MensCombo1.exec()

            elif not self.lineEdit_5.text():
                MensCombo2 = QMessageBox()
                MensCombo2.setIcon(QMessageBox.Warning)
                MensCombo2.setWindowTitle("Valor Overlap Vacio")
                MensCombo2.setText("Ingrese un Valor válido")
                returnValue = MensCombo2.exec()

            elif not self.lineEdit_7.text():
                MensCombo3 = QMessageBox()
                MensCombo3.setIcon(QMessageBox.Warning)
                MensCombo3.setWindowTitle("Valor Fs Vacio")
                MensCombo3.setText("Ingrese un Valor válido")
                returnValue = MensCombo3.exec()

            elif not self.lineEdit_9.text():
                MensCombo4 = QMessageBox()
                MensCombo4.setIcon(QMessageBox.Warning)
                MensCombo4.setWindowTitle("Nº Traza Vacio")
                MensCombo4.setText("Ingrese un Valor válido")
                returnValue = MensCombo4.exec()

            else:
                 # Filtrando con un lowpass en una copia de la traza original
                plt.close()  # cierra el gráfico existente

                #× Lectura del Registro y etiquetas
                archivoFil2 = (self.label_2.text())             # Lectura etiqueta del Registro

                frecM = (self.lineEdit_2.text())                # Lectura etiqueta de Frec. Min.
                frecMax = (self.lineEdit_3.text())              # Lectura etiqueta de Frec. Max.
                orden6 = (self.lineEdit_6.text())               # Lectura del orden del filtro

                # Convertir a flotante los valores string del texto de las cajas del filtro
                frec7=float(frecM)                              # Convierte a flotante el valor de la Frec. Min.
                frec8=float(frecMax)                            # Convierte a flotante el valor de la Frec. Max.
                orden7=int(orden6)                              # Convierte a entero el valor del orden del filtro

                frec1 = (self.lineEdit_4.text())                # Lectura etiqueta de la NFFT
                frec2 = (self.lineEdit_5.text())                # Lectura etiqueta del noverlap
                frec3 = (self.lineEdit_7.text())                # Lectura etiqueta de Fs

                # Convertir a entero los valores string de las cajas de texto para los valores del espectrograma
                frec4=int(frec1)                                # Convierte el valor de NFFT
                frec5=int(frec2)                                # Convierte el valor de overlap
                frec6=int(frec3)                                # Convierte el valor de Fs

                st  = obspy.read(archivoFil2)  # Lectura archivo de acuerdo al formato

                # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                NTraza = (self.lineEdit_9.text())               # Lectura del contenido de la caja de texto Nº Traza st[0]
                Ntraza2 = int(NTraza)                           # Convierte el valor del Nº de Traza a entero
                tr = st[Ntraza2]                                # Asigna el número de traza indicado al Stream para tratamiento del registro

                # Para establecer los valores del filtro

                tr.stats.station
                tr_filt = tr.copy()

                tr_filt.filter('bandpass', freqmin=frec7, freqmax=frec8, corners=orden7, zerophase=True)
                # Donde corners = orden del filtro

                npts = st[0].stats.npts
                # hasta aqui valores para el filtro ******

                tr.stats.station
                # Cálculo del valor del vector de tiempo general
                t = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)

                ax = plt.subplot(311)
                plt.plot(t, tr.data, 'k', label='Original Record')          # Where 'k' it's the color = black
                plt.ylabel('Record amplitude', color ="blue")
                #plt.legend(('Registro Raw'), prop = {'size': 10}, loc='upper right')
                # legend toma el valor de label en plot para presentar la leyenda
                plt.legend(prop = {'size': 10}, loc='upper right')
                plt.grid()   # presenta la cuadricula en el grafico

                plt.subplot(312, sharex=ax)
                plt.plot(t, tr_filt.data, 'b', label='Filtered Record ')
                plt.legend(prop = {'size': 10}, loc='upper right')  # Para colocar la leyenda a la izquierda
                plt.ylabel('Filtered records Highpass', color ="blue")
                plt.suptitle("Record: %s " % tr.stats.starttime, color ="red")
                plt.grid()                                      # presenta la cuadricula en el grafico

                plt.subplot(313, sharex=ax)
                # color puede ser: (cmap="gray") -> gris  (cmap="jet") -> colores
                # mode puede ser: 'default', 'psd', 'magnitude', 'angle', 'phase'
                plt.specgram(tr_filt.data, NFFT=frec4, Fs=frec6, mode='magnitude', noverlap=frec5, cmap="jet")

                # Formato de los valores del espectrograma

                plt.ylabel('Frequency [Hz]', color ="blue")
                plt.xlabel('Time [s]', color ="red")
                #plt.ylim(0, 100)  # Sets the limit in frequency (Hz) for the y-axis graph
                plt.suptitle("Record: %s " % tr.stats.starttime, color ="red")
                plt.grid()   # presenta la cuadricula en el grafico

                clb = plt.colorbar(orientation='horizontal')
                # Label format for spectrogram colormap.
                clb.set_label('Scale of Values in (%) of Energy, Spectrogram (Dark red = Higher %)', labelpad=5, y=1.05, rotation=0, fontsize=14, color ="blue")

                plt.show()

                # Seismic record statistics calculations
                datos = tr.data
                # Calculate the arithmetic mean
                Ftr = datos.mean()
                # Calculate the median
                FMed = np.median(datos)
                # Calculate the standard deviation
                DT = np.std(datos)
                # Calculate the variance
                VAR = np.var(datos)

                # Record Statistics Printing
                msg_e1 = "%s %s %s %s %s %s %s %s %s %s %s %s %s %s" % (" The arithmetic mean is: ", Ftr, " | The median is: ", FMed,
                         " | The standard deviation is: ", DT, " | The variance is: ", VAR,
                         "| The fs  (Hz) is:", tr.stats.sampling_rate, "| The Number of Samples is: ", tr.stats.npts, "| The Format is :", tr.stats._format)

                msg_e2 = "%s" % (tr.stats)

                stream = Stream(traces=[st])                # Para presentar el numero de trazas total
                A5 = (Stream.__str__(st, extended=True))    # Variable que contiene el numero total de trazas del registro
                mg3 = "%s" %(A5)                            # convertir a string o texto los datos de las trazas

                # Formato para los valores del texto en las estadísticas y cuadro de texto
                font=QtGui.QFont()
                font.setFamily("Times New Roman")
                font.setPointSize(8)
                font.setBold(False)
                font.setItalic(False)
                font.setWeight(60)

                self.label_9.setFont(font)                  # Impresion mediante el formato de texto
                self.label_9.setText(msg_e1)                # Impresión en la eiqueta de la estadistica del Registro
                self.textEdit.setText(msg_e2)               # Coloca la información de Metadatos en el cuadro de texto
                self.textEdit_2.setText(mg3)                # Coloca la información del Nº de Trazas en el cuadro de texto 2

        except:
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Input or Record File")
                returnValue = msgBox.exec()

    def envolver1(self):                                    # 3.- Function that allows you to build the Envelope.

        try:
            # Verify that the text box is not empty
            if not self.lineEdit.text():
                MensCombo1 = QMessageBox()
                MensCombo1.setIcon(QMessageBox.Warning)
                MensCombo1.setWindowTitle("Empty Frequency")
                MensCombo1.setText("Please, enter a valid Value")
                returnValue = MensCombo1.exec()

            # Verificar que la caja de texto de Orden del Filter no esté vacio
            elif not self.lineEdit_6.text():
                MensCombo2 = QMessageBox()
                MensCombo2.setIcon(QMessageBox.Warning)
                MensCombo2.setWindowTitle("Empty Filter Order")
                MensCombo2.setText("Please, enter a valid Value")
                returnValue = MensCombo2.exec()

            # Verificar que la caja de texto de Frecuencia Mínima no esté vacía
            elif not self.lineEdit_2.text():
                MensCombo3 = QMessageBox()
                MensCombo3.setIcon(QMessageBox.Warning)
                MensCombo3.setWindowTitle("Time Min. Vacio")
                MensCombo3.setText("Please, enter a valid Value")
                returnValue = MensCombo3.exec()

            # Verificar que la caja de texto de Frecuencia Máxima no esté vacía
            elif not self.lineEdit_3.text():
                MensCombo4 = QMessageBox()
                MensCombo4.setIcon(QMessageBox.Warning)
                MensCombo4.setWindowTitle("Time Max. Vacio")
                MensCombo4.setText("Please, enter a valid Value")
                returnValue = MensCombo4.exec()

            elif not self.lineEdit_9.text():
                MensCombo5 = QMessageBox()
                MensCombo5.setIcon(QMessageBox.Warning)
                MensCombo5.setWindowTitle("Trace No. Empty")
                MensCombo5.setText("Please, enter a valid Value")
                returnValue = MensCombo5.exec()

            else:
                # Filtrando con un lowpass en una copia de la traza original
                plt.close()                                                 # Close the existing chart.

                A1 = (self.label_2.text())                                  # Lectura etiqueta del Record
                F1 = (self.lineEdit.text())                                 # Lectura etiqueta de la Frecuencia
                Or1 = (self.lineEdit_6.text())                              # Lectura del orden del Filter
                FMin = (self.lineEdit_2.text())                             # Lectura etiqueta de Frec. Min.
                FMax = (self.lineEdit_3.text())                             # Lectura etiqueta de Frec. Max.

                # Convertir a flotante el valor string de la caja de texto
                F2=float(F1)                                                # Convierte el valor de Frecuencia a flotante
                Or2=int(Or1)                                                # Convierte el valor del orden del filtro a entero
                F3=float(FMin)                                              # Convierte a flotante el valor de la Frec. Min.
                F4=float(FMax)                                              # Convierte a flotante el valor de la Frec. Max.

                st  = obspy.read(A1)                                        # Lectura archivo de acuerdo al formatoç

                # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                NTraza = (self.lineEdit_9.text())                           # Lectura del contenido de la caja de texto Nº Traza st[0]
                Ntraza2 = int(NTraza)                                       # Convierte el valor del Nº de Traza a entero
                tr = st[Ntraza2]                                            # Asigna el número de traza indicado al Stream para tratamiento del registro

                tr.stats.station

                data = st[0].data



                npts = st[0].stats.npts

                samprate = st[0].stats.sampling_rate
                # Filtering the Stream object
                st_filt = st.copy()

                data = np.where(data==min(data),0,data)

                st.filter('lowpass', freq=F2, corners=Or2, zerophase=True)
                # Envelope del Record filtrado
                data_envelope = obspy.signal.filter.envelope(st_filt[0].data)
                # Time para graficar
                t = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)
                #t = np.arange(0, npts / samprate, 1 / samprate)

                plt.plot(t, st_filt[0].data,  'k', label = 'Filtered Record')
                #plt.plot(t, st_filt[0].data,  'k', label = 'Filtered Record')
                # color para plot: k=black, r=red, b=blue,
                # lineas-> : = estilo de línea punteada, -- = estilo de línea discontinua
                plt.plot(t, data_envelope, 'b--', label = 'Envolvente')
                plt.legend(prop = {'size': 10}, loc='upper right')
                plt.suptitle("Record: %s " % tr.stats.starttime, color ="red")
                plt.title(u'Record (Lowpass Filter)/Envelope', color ="darkgreen" )  # Ponemos un título
                plt.ylabel('Filter data-> (lowpass)/Envelope', color = "blue")
                plt.xlabel('Time [s]', color ="red")
                plt.grid()                                                  # presenta la cuadricula en el grafico
                plt.xlim(F3, F4)                                            # Limites minimo y maximo de corte en el tiempo
                plt.show()

                # Seismic record statistics calculations
                datos = tr.data
                # Calculate the arithmetic mean
                Ftr = datos.mean()
                # Calculate the median
                FMed = np.median(datos)
                # Calculate the standard deviation
                DT = np.std(datos)
                # Calculate the variance
                VAR = np.var(datos)

                # Record Statistics Printing
                msg_e1 = "%s %s %s %s %s %s %s %s %s %s %s %s %s %s" % (" The arithmetic mean is: ", Ftr, " | The median is: ", FMed,
                         " | The standard deviation is: ", DT, " | The variance is: ", VAR,
                         "| The fs  (Hz) is:", tr.stats.sampling_rate, "| The Number of Samples is: ", tr.stats.npts, "| The Format is :", tr.stats._format)

                msg_e2 = "%s" % (tr.stats)

                stream = Stream(traces=[st])                                # Para presentar el numero de trazas total
                A5 = (Stream.__str__(st, extended=True))                    # Variable que contiene el numero total de trazas del registro
                mg3 = "%s" %(A5)                                            # convertir a string o texto los datos de las trazas

                # Formato para los valores del texto en las estadísticas y cuadro de texto
                font=QtGui.QFont()
                font.setFamily("Times New Roman")
                font.setPointSize(8)
                font.setBold(False)
                font.setItalic(False)
                font.setWeight(60)

                self.label_9.setFont(font)                                  # Impresion mediante el formato de texto
                self.label_9.setText(msg_e1)                                # Impresión en la eiqueta de la estadistica del Record
                self.textEdit.setText(msg_e2)                               # Coloca la información de Metadatos en el cuadro de texto
                self.textEdit_2.setText(mg3)                                # Coloca la información del Nº de Trazas en el cuadro de texto 2

        except:
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Input or Record File")
                returnValue = msgBox.exec()

    def PWelch(self):                                                       # 4.- function to calculate the power spectral density, using the Welch method

        try:

            if not self.lineEdit_9.text():
                MensCombo3 = QMessageBox()
                MensCombo3.setIcon(QMessageBox.Warning)
                MensCombo3.setWindowTitle("Trace No. Empty")
                MensCombo3.setText("Please, enter a valid Value")
                returnValue = MensCombo3.exec()

            else:

                plt.close()                                                 # Close the existing chart.

                A2 = (self.label_2.text())                                  # Reading the Record Label

                st  = obspy.read(A2)                                        # Reading the file according to the format

                # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                NTraza = (self.lineEdit_9.text())                           # Lectura del contenido de la caja de texto Nº Traza st[0]
                Ntraza2 = int(NTraza)                                       # Convierte el valor del Nº de Traza a entero
                tr = st[Ntraza2]                                            # Asigna el número de traza indicado al Stream para tratamiento del registro

                tr.stats.station
                N = len(tr.data)                                            # Tamaño de los datos (Data size) del registro

                # Proceso de calculo
                time = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)
                fs  = tr.stats.sampling_rate

                plt.subplot(311)

                plt.plot(time, tr.data, 'k', label='Original Record')       # Where 'k' is the color = black
                plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left
                plt.ylabel('Record - Amplitude', color ="blue")
                plt.xlabel('Time [s]', color = "red")

                plt.suptitle("Record : %s " % tr.stats.starttime , color ="darkgreen")
                plt.title("Spectral Power Density (PSD), by Welch's method, Window = hann",  color ="darkblue" )
                plt.grid()                                                  # Shows the grid on the graph

                # Calculate and plot the power spectral density.
                plt.subplot(312)
                f, Pxx_den = signal.welch(tr.data, fs, nperseg=1024)

                f_med, Pxx_den_med = signal.welch(tr.data, fs, nperseg=1024, average='median')
                plt.semilogy(f, Pxx_den, label='Mean')
                plt.semilogy(f_med, Pxx_den_med, label='Median')

                plt.semilogy(f, Pxx_den)
                plt.ylabel('PSD [V**2/Hz]', color = "blue")
                plt.legend()
                plt.grid()

                plt.subplot(313)
                # Al promediar la última mitad de la densidad espectral, para excluir el pico,
                # se puede recuperar la potencia de ruido en la señal.
                np.mean(Pxx_den[256:])
                # Ahora se calcula y grafica el poder espectral.
                f, Pxx_spec = signal.welch(tr.data, fs, 'flattop', 1024, scaling='spectrum')

                f_med, Pxx_den_med = signal.welch(tr.data, fs, nperseg=1024, average='median')
                plt.semilogy(f, Pxx_den, label='Mean')
                plt.semilogy(f_med, Pxx_den_med, label='Median')
                # Si promediamos la última mitad de la densidad espectral, para excluir el pico, podemos recuperar la potencia de ruido en la señal.
                # La altura de pico en el espectro de potencia es una estimación de la amplitud RMS.
                plt.semilogy(f, np.sqrt(Pxx_spec), label='PSD - Excluding the peak')

                # Para Colocar texto dentro de la gráfica con las coordenadas en  los ejes x,y
                # plt.text(15, 500, r'$\sin(x) \cdot e^{-x}$', fontsize=12, color="blue")   # Ejemplo:
                # La altura de pico en el espectro de potencia es una estimación de la amplitud RMS.
                # np.sqrt(Pxx_spec.max())
                plt.title("The peak height in the power spectrum is an estimate of the amplitude RMS = %s " % np.sqrt(Pxx_spec.max()), color ="darkblue")
                plt.xlabel('Frequency [Hz]', color = "red")
                plt.ylabel('Linear Spectrum  [V RMS] - Amplitude RMS', color = "blue")
                plt.legend()
                plt.grid()                                                  # Shows the grid on the graph

                plt.show()

                # Seismic record statistics calculations
                datos = tr.data
                # Calculate the arithmetic mean
                Ftr = datos.mean()
                # Calculate the median
                FMed = np.median(datos)
                # Calculate the standard deviation
                DT = np.std(datos)
                # Calculate the variance
                VAR = np.var(datos)

                # Record Statistics Printing
                msg_e1 = "%s %s %s %s %s %s %s %s %s %s %s %s %s %s" % (" The arithmetic mean is: ", Ftr, " | The median is: ", FMed,
                         " | The standard deviation is: ", DT, " | The variance is: ", VAR,
                         "| The fs  (Hz) is:", tr.stats.sampling_rate, "| The Number of Samples is: ", tr.stats.npts, "| The Format is :", tr.stats._format)

                msg_e2 = "%s" % (tr.stats)

                stream = Stream(traces=[st])                                # Para presentar el numero de trazas total
                A5 = (Stream.__str__(st, extended=True))                    # Variable que contiene el numero total de trazas del registro
                mg3 = "%s" %(A5)                                            # convertir a string o texto los datos de las trazas


                # Formato para los valores del texto en las estadísticas y cuadro de texto
                font=QtGui.QFont()
                font.setFamily("Times New Roman")
                font.setPointSize(8)
                font.setBold(False)
                font.setItalic(False)
                font.setWeight(60)

                self.label_9.setFont(font)                                  # Impresion mediante el formato de texto
                self.label_9.setText(msg_e1)                                # Impresión en la eiqueta de la estadistica del Record
                self.textEdit.setText(msg_e2)                               # Coloca la información de Metadatos en el cuadro de texto
                self.textEdit_2.setText(mg3)                                # Coloca la información del Nº de Trazas en el cuadro de texto 2

        except:
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Input or Record File")
                returnValue = msgBox.exec()

    def densidad1(self):                                                    # 5.- Function that allows to build the Classical periodogram plus five types of Welch window.

        try:

            if not self.lineEdit_9.text():
                MensCombo3 = QMessageBox()
                MensCombo3.setIcon(QMessageBox.Warning)
                MensCombo3.setWindowTitle("Trace No. Empty")
                MensCombo3.setText("Please, enter a valid Value")
                returnValue = MensCombo3.exec()

            else:

                plt.close()                             # Close the existing chart.

                # ========= Estilo profesional ==========
                plt.style.use('seaborn-darkgrid')

                A2 = (self.label_2.text())              # Lectura etiqueta del Record

                st  = obspy.read(A2)                    # Lectura archivo de acuerdo al formato

                # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                NTraza = (self.lineEdit_9.text())       # Lectura del contenido de la caja de texto Nº Traza st[0]
                Ntraza2 = int(NTraza)                   # Convierte el valor del Nº de Traza a entero
                tr = st[Ntraza2]                        # Asigna el número de traza indicado al Stream para tratamiento del registro

                data = tr.data                        # Señal sísmica real
                fs = tr.stats.sampling_rate           # Frecuencia de muestreo

                tr.stats.station
                N = len(tr.data)                        # Tamaño de los datos (Data size) del registro

                nombre_registro = tr.stats.station    # Nombre del registro para subtítulo

                # ========= Dynamic adjustment of nperseg ==========
                # Used: 1/8 of the total, minimum 256 and maximum 4096
                nperseg = min(max(256, N // 8), 4096)

                #print(f"Signal length: {N}")
                #print(f"Adjusted nperseg: {nperseg}")

                # Periodogram calculation process
                # ========= Window settings for the Welch method ==========
                ventanas = ["hann", "hamming", "bartlett", "blackman", "flattop"]
                # A consistent color palette is used with a dark grid background in Seaborn
                colores = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd"]

                # ========= Figure 1 is created: with individual subplots with shared axes ==========
                fig1, axes1 = plt.subplots(nrows=3, ncols=2, figsize=(10, 7), sharex=True, sharey=True)
                axes1 = axes1.flatten()

                # --- Classical periodogram, code for calculation. ---
                f_full, Pxx_full = periodogram(data, fs=fs)
                axes1[0].semilogy(f_full, Pxx_full, color="black", linewidth=2.5)
                axes1[0].set_title("Classical periodogram")
                axes1[0].set_ylabel(r"$S_x(f)\ [V^2/Hz]$")
                axes1[0].grid(True)


                # --- Algorithm for Welch method with different calculation windows. ---
                resultados = []
                for i, (win, col) in enumerate(zip(ventanas, colores), start=1):
                    f_w, Pxx_w = welch(data, fs=fs, window=win, nperseg=nperseg)

                    axes1[i].semilogy(f_w, Pxx_w, color=col, linewidth=2)
                    axes1[i].set_title(f"Welch ({win})")
                    axes1[i].set_xlabel("Frequency [Hz]")
                    axes1[i].set_ylabel(r"Periodogram: $S_x(f)\ [V^2/Hz]$")
                    axes1[i].grid(True)


                    # Save information for the summary table
                    resultados.append({"Window ": win, "nperseg ": nperseg, "Δf (Hz) ": fs/nperseg})

                    #resultados.append.columns = resultados.append.columns.str.replace('', '  ')   # Aumentar la separación de espacios entre columnas en la tabla de resulatados.


                # Setting common limits in Welch method windows
                Pxx_max = max(Pxx_full) * 1.1
                Pxx_min = min(Pxx_full[Pxx_full>0]) / 10
                for ax in axes1:
                    ax.set_xlim(0, fs/2)
                    ax.set_ylim(Pxx_min, Pxx_max)
                    ax.set_xlabel("Frequency [Hz]")
                    # Mejorar legibilidad del eje X
                    ax.tick_params(axis='x', labelrotation=45, labelsize=9)
                    ax.tick_params(axis='y', labelsize=9)


                plt.tight_layout()
                #fig1.suptitle(f"Espectros individuales del registro: {nombre_registro}", fontsize=14, y=1.02)
                plt.show()


                # ========= Figura 2: comparación de todos (log Y) ==========
                fig2, ax2 = plt.subplots(figsize=(12, 6))

                # Periodograma clásico destacado
                ax2.semilogy(f_full, Pxx_full, label="Classical periodogram", color="black", linewidth=3)

                # Welch semi-transparentes
                for win, col in zip(ventanas, colores):
                    f_w, Pxx_w = welch(data, fs=fs, window=win, nperseg=nperseg)
                    ax2.semilogy(f_w, Pxx_w, label=f"Welch ({win})", color=col, linewidth=2, alpha=0.7)

                ax2.set_title(f"Welch methods Comparison: {nombre_registro} %s " % tr.stats.starttime, fontsize=14)
                ax2.set_xlabel("Frequency [Hz]")
                ax2.set_ylabel(r"Periodogram: $S_x(f)\ [V^2/Hz]$")
                ax2.set_xlim(0, fs/2)
                ax2.set_ylim(Pxx_min, Pxx_max)
                ax2.set_yscale('log')
                ax2.grid(True, which="both", ls="--", lw=0.5)
                ax2.legend(frameon=True, fontsize=10, loc='upper right')
                plt.tight_layout()
                plt.show()

                # ========= Summary table ==========
                tabla = pd.DataFrame(resultados)
                #print("\nSummary, Welch Periodogram methods:\n")
                #print(tabla)

                # Convert table to string
                tabla_str = tabla.to_string(index=False)

                # ========= Export results to an Excel table (optional - enable if you want to use) ==========
                # tabla.to_excel("resumen_metodos_Welch.xlsx", index=False)
                # print("\nTabla guardada como: 'resumen_metodos_Welch.xlsx'")


                # Seismic record statistics calculations
                datos = tr.data
                # Calculate the arithmetic mean
                Ftr = datos.mean()
                # Calculate the median
                FMed = np.median(datos)
                # Calculate the standard deviation
                DT = np.std(datos)
                # Calculate the variance
                VAR = np.var(datos)

                # Record Statistics Printing
                msg_e1 = "%s %s %s %s %s %s %s %s %s %s %s %s %s %s" % (" The arithmetic mean is: ", Ftr, " | The median is: ", FMed,
                         " | The standard deviation is: ", DT, " | The variance is: ", VAR,
                         "| The fs  (Hz) is:", tr.stats.sampling_rate, "| The Number of Samples is: ", tr.stats.npts, "| The Format is :", tr.stats._format)


                # ========= Display metadata values ​​+ table in textEdit ==========
                msg_e2 = f"Record metadata:\n{tr.stats}\n\nSummary, Welch Periodogram methods:\n{tabla_str}"

                stream = Stream(traces=[st])                                # To present the total number of traces
                A5 = (Stream.__str__(st, extended=True))                    # Variable that contains the total number of traces in the seismic record
                mg3 = "%s" %(A5)                                            # convert trace data to string or text

                # Format for text values ​​in statistics and text boxes
                font=QtGui.QFont()
                font.setFamily("Times New Roman")
                font.setPointSize(8)
                font.setBold(False)
                font.setItalic(False)
                font.setWeight(60)

                self.label_9.setFont(font)                                  # Printing using text format
                self.label_9.setText(msg_e1)                                # Printing on the Record Statistics Label
                self.textEdit.setText(msg_e2)                               # Place the Metadata + table information in the text box
                self.textEdit_2.setText(mg3)                                # Display the Trace Number information in text box 2

        except:
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Input or Record File")
                returnValue = msgBox.exec()


    def Twawelet1(self):                                                    # 6.- Function to build the continuous Wawelet Transform (CWT)

        try:
            # Verify that the text box, Minimum Frequency is not empty
            if not self.lineEdit_2.text():
                MensCombo1 = QMessageBox()
                MensCombo1.setIcon(QMessageBox.Warning)
                MensCombo1.setWindowTitle("Empty Min. Freq.")
                MensCombo1.setText("Please, enter a valid Value")
                returnValue = MensCombo1.exec()

            # Verify that the Maximum Frequency text box is not empty
            elif not self.lineEdit_3.text():
                MensCombo2 = QMessageBox()
                MensCombo2.setIcon(QMessageBox.Warning)
                MensCombo2.setWindowTitle("Empty Max. Freq.")
                MensCombo2.setText("Please, enter a valid Value")
                returnValue = MensCombo2.exec()

            # Verify that the Trace Number box is not empty
            elif not self.lineEdit_9.text():
                MensCombo3 = QMessageBox()
                MensCombo3.setIcon(QMessageBox.Warning)
                MensCombo3.setWindowTitle("Trace No. Empty")
                MensCombo3.setText("Please, enter a valid Value")
                returnValue = MensCombo3.exec()

            else:

                plt.close()                             # Close the existing chart.

                # Lectura del Record y etiquetas
                ArchiWave1 = (self.label_2.text())      # Lectura etiqueta del Record

                FMin2 = (self.lineEdit_2.text())        # Lectura etiqueta de Frec. Min.
                FMax2 = (self.lineEdit_3.text())        # Lectura etiqueta de Frec. Max.

                # Convertir a flotante el valor string de la caja de texto
                F5=float(FMin2)                         # Convierte a flotante el valor de la Frec. Min.
                F6=float(FMax2)                         # Convierte a flotante el valor de la Frec. Max.

                st  = obspy.read(ArchiWave1)            # Lectura archivo de acuerdo al forma

                # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                NTraza = (self.lineEdit_9.text())       # Lectura del contenido de la caja de texto Nº Traza st[0]
                Ntraza2 = int(NTraza)                   # Convierte el valor del Nº de Traza a entero
                tr = st[Ntraza2]                        # Asigna el número de traza indicado al Stream para tratamiento del registro

                tr.stats.station
                # Calculation of the value of the time vector
                t = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)

                ax = plt.subplot(211)
                plt.plot(t, tr.data, 'k', label='Original Record')          # Where 'k' is the color = black
                # "legend", takes the value of label in plot to display the legend
                plt.legend(prop = {'size': 10}, loc='upper right')          # To place the legend on the left
                plt.ylabel('Registry Amplitude', color ="blue")
                plt.grid()                                                  # display the grid on the chart

                plt.subplot(212, sharex=ax)                                 # Subplot para graficar la CWT
                npts = tr.stats.npts
                dt = tr.stats.delta
                t1 = np.linspace(0, dt * npts, npts)
                scalogram = cwt(tr.data, dt, 8, F5, F6)
                x, y = np.meshgrid(
                t1,
                np.logspace(np.log10(F5), np.log10(F6), scalogram.shape[0]))
                plt.pcolormesh(x, y, np.abs(scalogram),  shading= 'auto', cmap="jet")

                plt.title(u'Continuous Wawelet Transform', color ="darkgreen" ) # We put a title
                plt.xlabel("Time %s [s] " % tr.stats.starttime, color ="red")
                plt.suptitle("Record: %s " % tr.stats.starttime, color ="red")

                plt.ylabel("Frequency [Hz]", color="blue")
                plt.yscale('log')                                           # y-axis scale, logarithmic
                plt.ylim(F5, F6)                                            # Determine the range of frequencies to represent on the graph
                plt.show()

                # Seismic record statistics calculations
                datos = tr.data
                # Calculate the arithmetic mean
                Ftr = datos.mean()
                # Calculate the median
                FMed = np.median(datos)
                # Calculate the standard deviation
                DT = np.std(datos)
                # Calculate the variance
                VAR = np.var(datos)

                # Record Statistics Printing
                msg_e1 = "%s %s %s %s %s %s %s %s %s %s %s %s %s %s" % (" The arithmetic mean is: ", Ftr, " | The median is: ", FMed,
                         " | The standard deviation is: ", DT, " | The variance is: ", VAR,
                         "| The fs  (Hz) is:", tr.stats.sampling_rate, "| The Number of Samples is: ", tr.stats.npts, "| The Format is :", tr.stats._format)

                msg_e2 = "%s" % (tr.stats)                                  # To present the metadata information

                stream = Stream(traces=[st])                                # To display the total number of traces
                A5 = (Stream.__str__(st, extended=True))                    # Variable that contains the total number of traces of the seismic record
                mg3 = "%s" %(A5)                                            # convert trace data to string or text

                # Format for text values in statistics and text box
                font=QtGui.QFont()
                font.setFamily("Times New Roman")
                font.setPointSize(8)
                font.setBold(False)
                font.setItalic(False)
                font.setWeight(60)

                self.label_9.setFont(font)                                  # Printing using the text format
                self.label_9.setText(msg_e1)                                # Printing on the label of the seismic record statistics
                self.textEdit.setText(msg_e2)                               # Place the Metadata information in the text box
                self.textEdit_2.setText(mg3)                                # Place the information of the Number of Traces in the text box 2

        except:
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Input or Record File")
                returnValue = msgBox.exec()

    def Coefici1(self):                                                     # 7.- Discrete Wavelet Coefficient Analysis Function

        try:
            # Verify that the Discrete Wavelets Coefficients text box is not empty
            if not self.lineEdit_8.text():
                MensCombo1 = QMessageBox()
                MensCombo1.setIcon(QMessageBox.Warning)
                MensCombo1.setWindowTitle("Empty Coefficient")
                MensCombo1.setText("Please, enter a valid Value")
                returnValue = MensCombo1.exec()

            elif not self.lineEdit_9.text():
                MensCombo2 = QMessageBox()
                MensCombo2.setIcon(QMessageBox.Warning)
                MensCombo2.setWindowTitle("Trace No. Empty")
                MensCombo2.setText("Please, enter a valid Value")
                returnValue = MensCombo2.exec()

            else:

                plt.close()                                 # Close the existing chart.

                # Reading the "seismic record" and labels
                ArchiWave8 = (self.label_2.text())          # Reading the "seismic record"
                waveletname = (self.lineEdit_8.text())      # Discrete Coefficient Type Label Reading

                st  = obspy.read(ArchiWave8)                # Reading file according to format using the Obspy library

                # Enter and convert to integer the string value of the No. Traces st[0] text box
                NTraza = (self.lineEdit_9.text())           # Reading the content of the text box Trace No. st[0]
                Ntraza2 = int(NTraza)                       # Converts the value of the Trace Number to integer
                tr = st[Ntraza2]                            # Assigns the indicated trace number to the Stream, for record treatment

                tr.stats.station
                # Calculation of the value of the time vector
                t = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)
                # Wavelet Discrete Coefficients
                """Tipos de Coeficientes discretos Wavelet que se pueden utilizar ----,
                'bior1.1' 'bior1.3' 'bior1.5' 'bior2.2' 'bior2.4' 'bior2.6' 'bior2.8' 'bior3.1'
                'bior3.3' 'bior3.5' 'bior3.7' 'bior3.9' 'bior4.4' 'bior5.5' 'bior6.8' 'coif1'
                'coif2' 'coif3' 'coif4' 'coif5' 'coif6' 'coif7' 'coif8' 'coif9' 'coif10' 'coif11'
                'coif12' 'coif13' 'coif14' 'coif15' 'coif16' 'coif17' 'db1' 'db2' 'db3' 'db4' 'db5'
                'db6' 'db7' 'db8' 'db9' 'db10', 'db11' 'db12' 'db13' 'db14' 'db15' 'db16' 'db17' 'db18'
                'db19' 'db20' 'db21' 'db22', 'db23' 'db24' 'db25' 'db26' 'db27' 'db28' 'db29' 'db30'
                'db31' 'db32' 'db33' 'db34' 'db35' 'db36' 'db37' 'db38' 'dmey' 'haar' 'rbio1.1'
                'rbio1.3' 'rbio1.5' 'rbio2.2' 'rbio2.4' 'rbio2.6' 'rbio2.8' 'rbio3.1' 'rbio3.3'
                'rbio3.5' 'rbio3.7' 'rbio3.9' 'rbio4.4' 'rbio5.5' 'rbio6.8' 'sym2' 'sym3' 'sym4'
                'sym5' 'sym6' 'sym7' 'sym8' 'sym9' 'sym10' 'sym11' 'sym12' 'sym13' 'sym14'
                'sym15' 'sym16' 'sym17' 'sym18' 'sym19' 'sym20'
                'Puede teclear o copiar y pegar sin comillas el nombre que desee utilizar en el cuadro de texto' """
                # Example: waveletname = 'sym20'   (test)

                fig, ax = plt.subplots(figsize=(8,5))
                ax.set_title("Original Record:  (Graph 2, Shows the Coefficients)")
                ax.plot(t, tr.data)
                plt.suptitle("Graph 1 - Record: %s " % tr.stats.starttime, color ="red")
                plt.xlabel("Time %s [s] " % tr.stats.starttime, color ="red")
                plt.ylabel('Record - Amplitude', color ="blue")
                plt.grid()                                                  # display the grid on the chart
                plt.show()

                fig, axarr = plt.subplots(nrows=5, ncols=2, figsize=(8,5))  # Subplot configuration
                # 5 rows, 2 columns, Size 8 x 5
                for i in range(5):                                          # from i to 5 range
                    (tr.data, coeff_d) = pywt.dwt(tr.data, waveletname)     # Construction of the data and the Wavelet
                    axarr[i, 0].plot(tr.data, 'b')                          # Data plots
                    axarr[i, 1].plot(coeff_d, 'k')                          # Wawelets coefficients plots
                    axarr[i, 1].grid()                                      # display the grid on the chart
                    axarr[i, 0].set_ylabel("Level {}".format(i + 1), fontsize=12, rotation=90, color ="blue")  # y-axis labels
                    axarr[i, 0].set_yticklabels([])                         # Display the labels on the y-axis
                    axarr[i, 0].grid()                                      # display the grid on the chart
                    if i == 0:
                        axarr[i, 0].set_title("Approximation Wavelet coefficients", fontsize=14, color = "red")     # Title settings, left part
                        axarr[i, 1].set_title("Wavelet Coefficients Detail", fontsize=14, color = "red")            # Title settings, right side
                    axarr[i, 1].set_yticklabels([])                         # Display the labels on the y-axis

                # Label Title Top
                plt.suptitle("Graph 2 - Record: %s " % tr.stats.starttime + "- Discrete Wavelet Type %s " % waveletname, color ="darkgreen") # Label Title Top

                plt.tight_layout()                                          # Makes the chart expand
                plt.show()

                # Seismic record statistics calculations
                datos = tr.data
                # Calculate the arithmetic mean
                Ftr = datos.mean()
                # Calculate the median
                FMed = np.median(datos)
                # Calculate the standard deviation
                DT = np.std(datos)
                # Calculate the variance
                VAR = np.var(datos)

                # Record Statistics Printing
                msg_e1 = "%s %s %s %s %s %s %s %s %s %s %s %s %s %s" % (" The arithmetic mean is: ", Ftr, " | The median is: ", FMed,
                         " | The standard deviation is: ", DT, " | The variance is: ", VAR,
                         "| The fs  (Hz) is:", tr.stats.sampling_rate, "| The Number of Samples is: ", tr.stats.npts, "| The Format is :", tr.stats._format)

                msg_e2 = "%s" % (tr.stats)                                  # To present the metadata information

                stream = Stream(traces=[st])                                # To display the total number of traces
                A5 = (Stream.__str__(st, extended=True))                    # Variable that contains the total number of traces of the seismic record
                mg3 = "%s" %(A5)                                            # convert trace data to string or text

                # Text format
                font=QtGui.QFont()
                font.setFamily("Times New Roman")
                font.setPointSize(8)
                font.setBold(False)
                font.setItalic(False)
                font.setWeight(60)

                self.label_9.setFont(font)                                  # Printing using the text format
                self.label_9.setText(msg_e1)                                # Printing on the label of the seismic record statistics
                self.textEdit.setText(msg_e2)                               # Place the Metadata information in the text box
                self.textEdit_2.setText(mg3)                                # Place the information of the Number of Traces in the text box 2

        except:
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Input or Record File")
                returnValue = msgBox.exec()


    """ Function to go back at home- (Menu) """

    def abrir_programa1(self):                                              # Call function to another program (Back)
        if sistema == "Windows":                                            # If the system is Windows
            plt.close()                                                     # Close the existing chart.
            subprocess.Popen(["python", "Menu.py"])
            app.quit()
        else:                                                               # If the system is Linux
            plt.close()                                                     # Close the existing chart
            subprocess.Popen(["python3", "Menu.py"])
            app.quit()


    """  Fuction to exit system  """

    def Exit1(self):                                                        # Call function to show exit dialog box
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Question)
        msg.setWindowTitle("Exit Module 1 - Spectral Analysis")
        msg.setText("Are you sure to exit the Module 1 and System?")
        msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        msg.setDefaultButton(QMessageBox.Ok)                                # By default, the focus is on the OK button
        returnValue = msg.exec()
        if returnValue == QMessageBox.Ok:                                   # If the answer is OK
            app.closeAllWindows()                                           # Close all windows


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
    # Ligdamis A. Gutiérrez E. PhD.

