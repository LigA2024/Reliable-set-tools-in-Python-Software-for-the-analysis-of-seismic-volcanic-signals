# -*- coding: utf-8 -*-

# Created by: PyQt5 UI code generator 5.15.2 and modified by later code editing
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

# Developed by: Ligdamis A. Gutiérrez E. PhD.
# Seismic Analysis System - > Seismic Records Event Cut and Save

# Andalusian Institute of Geophysics
# Department of Theoretical Physics and the Cosmos,
# Science Faculty,
# Granada University, (Ugr), Spain, 2021 - 2023

''' WARNING: Do not modify or edit the code without permission of the author.
    In case of using this software, indicate and refer to the author and the institution he represents.
    The University of Granada, Ugr '''

# Program: Module 6 - Cut_1.pyw -> Cut events from a Seismic Record

# Part of the comments are written, both in English and in Castilian (Spanish).


# Load libraries to use

# For system use, threads and paths (path)
import sys
import os
import subprocess
from pathlib import Path

import warnings  # librería para alertas

# Libraries for graphics using matplotlib and using numpy, plotly
import numpy as np
from numpy import arange, array
from matplotlib import pyplot
from matplotlib.widgets import SpanSelector, MultiCursor

# Libraries for the use of PyQt5 - binding of the graphical Qt library
from PyQt5.QtWidgets import QApplication, QWidget, QMessageBox
from PyQt5 import QtCore, QtGui, QtWidgets, uic
from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton
from PyQt5.QtCore import QCoreApplication
from PyQt5.QtWidgets import *
import sys

from PyQt5 import QtGui

# Identify the operating system
import platform
sistema = platform.system()  # Identify the operating system

# Libraries to use tkinter (Graphical interface)
import tkinter
import tkinter as tk
from tkinter.ttk import Combobox, Style
from tkinter.messagebox import showerror, showinfo, askyesno
from tkinter import Frame, IntVar, Label, filedialog, Entry, Radiobutton, CURRENT

# En caso de utilizar la ventana como root (cambios a posteriori)
from tkinter import *
root = tk.Tk()
root.withdraw()

from os.path import join as os_path_join
from os.path import dirname as os_path_dirname

# import matplotlib.cbook as cbook
import numpy as np
from numpy import arange, array
from matplotlib import pyplot
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import matplotlib.pyplot as plt
from matplotlib.widgets import SpanSelector, MultiCursor

# To read records through the "obspy" library
import obspy
from obspy.imaging.cm import obspy_sequential
from obspy.signal.tf_misfit import cwt
from obspy import Stream
from obspy import read
from obspy.io.sac import SACTrace
from obspy import read, Trace

from obspy.core import UTCDateTime, Stream, Trace, read, AttribDict
from obspy.core.util import NamedTemporaryFile


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(724, 522)

        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(r"Images/Ugr.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        MainWindow.setWindowIcon(icon)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        self.frame_2 = QtWidgets.QFrame(self.centralwidget)
        self.frame_2.setGeometry(QtCore.QRect(10, 210, 701, 201))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.frame_2.setPalette(palette)
        self.frame_2.setFrameShape(QtWidgets.QFrame.Panel)
        self.frame_2.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_2.setObjectName("frame_2")

        self.label_4 = QtWidgets.QLabel(self.frame_2)
        self.label_4.setGeometry(QtCore.QRect(190, 30, 501, 41))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(170, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(170, 255, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(120, 120, 120))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.label_4.setPalette(palette)
        self.label_4.setAutoFillBackground(True)
        self.label_4.setFrameShape(QtWidgets.QFrame.Panel)
        self.label_4.setFrameShadow(QtWidgets.QFrame.Raised)
        self.label_4.setText("")
        self.label_4.setObjectName("label_4")

        self.label_5 = QtWidgets.QLabel(self.frame_2)
        self.label_5.setGeometry(QtCore.QRect(190, 10, 181, 16))
        self.label_5.setObjectName("label_5")

        self.line_5 = QtWidgets.QFrame(self.frame_2)
        self.line_5.setGeometry(QtCore.QRect(1, 90, 698, 20))
        self.line_5.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_5.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_5.setObjectName("line_5")

        self.line_15 = QtWidgets.QFrame(self.frame_2)
        self.line_15.setGeometry(QtCore.QRect(1, 0, 698, 2))
        self.line_15.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_15.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_15.setObjectName("line_15")

        self.label_6 = QtWidgets.QLabel(self.frame_2)
        self.label_6.setGeometry(QtCore.QRect(190, 120, 171, 16))
        self.label_6.setObjectName("label_6")

        self.label_7 = QtWidgets.QLabel(self.frame_2)
        self.label_7.setGeometry(QtCore.QRect(190, 140, 501, 41))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(220, 245, 220))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(220, 245, 220))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(120, 120, 120))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 240, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.label_7.setPalette(palette)
        self.label_7.setAutoFillBackground(True)
        self.label_7.setFrameShape(QtWidgets.QFrame.Panel)
        self.label_7.setFrameShadow(QtWidgets.QFrame.Raised)
        self.label_7.setText("")
        self.label_7.setObjectName("label_7")

        self.line_9 = QtWidgets.QFrame(self.frame_2)
        self.line_9.setGeometry(QtCore.QRect(170, 0, 16, 201))
        self.line_9.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_9.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_9.setObjectName("line_9")

        self.pushButton = QtWidgets.QPushButton(self.frame_2)
        self.pushButton.setGeometry(QtCore.QRect(30, 30, 101, 41))
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap("Images/Load.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton.setIcon(icon2)
        self.pushButton.setObjectName("pushButton")

        self.pushButton_3 = QtWidgets.QPushButton(self.frame_2)
        self.pushButton_3.setGeometry(QtCore.QRect(30, 130, 101, 41))
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap("Images/save_dir.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_3.setIcon(icon1)
        self.pushButton_3.setObjectName("pushButton_3")

        self.line_13 = QtWidgets.QFrame(self.frame_2)
        self.line_13.setGeometry(QtCore.QRect(0, 0, 5, 201))
        self.line_13.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_13.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_13.setObjectName("line_13")

        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(320, 190, 211, 20))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(170, 0, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)
        brush = QtGui.QBrush(QtGui.QColor(170, 0, 0, 128))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.PlaceholderText, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0, 128))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.PlaceholderText, brush)
        brush = QtGui.QBrush(QtGui.QColor(120, 120, 120))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0, 128))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.PlaceholderText, brush)
        self.label_3.setPalette(palette)
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setBold(True)
        font.setWeight(75)
        self.label_3.setFont(font)
        self.label_3.setObjectName("label_3")

        self.frame_4 = QtWidgets.QFrame(self.centralwidget)
        self.frame_4.setGeometry(QtCore.QRect(10, 10, 701, 171))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(216, 225, 240))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.frame_4.setPalette(palette)
        self.frame_4.setAutoFillBackground(True)
        self.frame_4.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_4.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_4.setObjectName("frame_4")


        self.pushButton_8 = QtWidgets.QPushButton(self.frame_4)
        self.pushButton_8.setGeometry(QtCore.QRect(580, 30, 101, 41))
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap("Images/Filter.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_8.setIcon(icon3)
        self.pushButton_8.setObjectName("pushButton_8")


        """ --- Values for Text Boxes (lineEdit) Frame 4 --- """

        self.lineEdit = QtWidgets.QLineEdit(self.frame_4)
        self.lineEdit.setGeometry(QtCore.QRect(490, 110, 71, 21))
        self.lineEdit.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit.setObjectName("lineEdit")

        self.lineEdit_2 = QtWidgets.QLineEdit(self.frame_4)
        self.lineEdit_2.setGeometry(QtCore.QRect(490, 140, 71, 21))
        self.lineEdit_2.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_2.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_2.setObjectName("lineEdit_2")

        self.lineEdit_5 = QtWidgets.QLineEdit(self.frame_4)
        self.lineEdit_5.setGeometry(QtCore.QRect(190, 140, 41, 21))
        self.lineEdit_5.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_5.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_5.setObjectName("lineEdit_5")

        self.lineEdit_6 = QtWidgets.QLineEdit(self.frame_4)
        self.lineEdit_6.setGeometry(QtCore.QRect(250, 50, 61, 20))
        self.lineEdit_6.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_6.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_6.setObjectName("lineEdit_6")

        self.lineEdit_7 = QtWidgets.QLineEdit(self.frame_4)
        self.lineEdit_7.setGeometry(QtCore.QRect(330, 140, 61, 20))
        self.lineEdit_7.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_7.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_7.setObjectName("lineEdit_7")

        self.lineEdit_8 = QtWidgets.QLineEdit(self.frame_4)
        self.lineEdit_8.setGeometry(QtCore.QRect(330, 110, 61, 20))
        self.lineEdit_8.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_8.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_8.setObjectName("lineEdit_8")

        self.lineEdit_9 = QtWidgets.QLineEdit(self.frame_4)
        self.lineEdit_9.setGeometry(QtCore.QRect(330, 50, 61, 20))
        self.lineEdit_9.setInputMethodHints(QtCore.Qt.ImhPreferNumbers)
        self.lineEdit_9.setAlignment(QtCore.Qt.AlignCenter)
        self.lineEdit_9.setObjectName("lineEdit_9")


        self.pushButton_2 = QtWidgets.QPushButton(self.frame_4)
        self.pushButton_2.setGeometry(QtCore.QRect(430, 30, 101, 41))
        icon4 = QtGui.QIcon()
        icon4.addPixmap(QtGui.QPixmap("Images/Clean.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_2.setIcon(icon4)
        self.pushButton_2.setObjectName("pushButton_2")

        """ --- Values for Text Labels (Label) Frame 4 --- """

        self.label_8 = QtWidgets.QLabel(self.frame_4)
        self.label_8.setGeometry(QtCore.QRect(602, 95, 71, 71))
        self.label_8.setText("")
        self.label_8.setPixmap(QtGui.QPixmap("Images/Ugr.gif"))
        self.label_8.setScaledContents(True)
        self.label_8.setObjectName("label_8")

        self.label_9 = QtWidgets.QLabel(self.frame_4)
        self.label_9.setGeometry(QtCore.QRect(410, 110, 71, 20))
        self.label_9.setObjectName("label_9")

        self.label_11 = QtWidgets.QLabel(self.frame_4)
        self.label_11.setGeometry(QtCore.QRect(410, 140, 61, 20))
        self.label_11.setObjectName("label_11")

        self.label_16 = QtWidgets.QLabel(self.frame_4)
        self.label_16.setGeometry(QtCore.QRect(100, 130, 81, 20))
        self.label_16.setObjectName("label_16")

        self.label_17 = QtWidgets.QLabel(self.frame_4)
        self.label_17.setGeometry(QtCore.QRect(110, 150, 71, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_17.setFont(font)
        self.label_17.setObjectName("label_17")

        self.label_18 = QtWidgets.QLabel(self.frame_4)
        self.label_18.setGeometry(QtCore.QRect(330, 30, 61, 16))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.label_18.setFont(font)
        self.label_18.setObjectName("label_18")

        self.label_19 = QtWidgets.QLabel(self.frame_4)
        self.label_19.setGeometry(QtCore.QRect(320, 20, 71, 16))
        self.label_19.setObjectName("label_19")

        self.label_20 = QtWidgets.QLabel(self.frame_4)
        self.label_20.setGeometry(QtCore.QRect(250, 140, 81, 16))
        self.label_20.setObjectName("label_20")

        self.label_21 = QtWidgets.QLabel(self.frame_4)
        self.label_21.setGeometry(QtCore.QRect(250, 110, 81, 16))
        self.label_21.setObjectName("label_21")

        self.label_22 = QtWidgets.QLabel(self.frame_4)
        self.label_22.setGeometry(QtCore.QRect(250, 30, 61, 16))
        self.label_22.setObjectName("label_22")


        self.groupBox_2 = QtWidgets.QGroupBox(self.frame_4)
        self.groupBox_2.setGeometry(QtCore.QRect(10, 20, 211, 101))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(240, 255, 247))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 255, 247))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(240, 255, 247))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.groupBox_2.setPalette(palette)
        self.groupBox_2.setAutoFillBackground(True)
        self.groupBox_2.setObjectName("groupBox_2")

        self.comboBox_2 = QtWidgets.QComboBox(self.groupBox_2)
        self.comboBox_2.setGeometry(QtCore.QRect(10, 20, 191, 22))
        self.comboBox_2.setObjectName("comboBox_2")
        self.comboBox_2.addItem("")
        self.comboBox_2.addItem("")
        self.comboBox_2.addItem("")
        self.comboBox_2.addItem("")
        self.comboBox_2.addItem("")


        """ --- Values for the separation lines on the canvas (line) Frame 4 --- """

        self.line_3 = QtWidgets.QFrame(self.frame_4)
        self.line_3.setGeometry(QtCore.QRect(230, 0, 20, 171))
        self.line_3.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_3.setObjectName("line_3")

        self.line_4 = QtWidgets.QFrame(self.frame_4)
        self.line_4.setGeometry(QtCore.QRect(390, 0, 20, 171))
        self.line_4.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_4.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_4.setObjectName("line_4")

        self.line_6 = QtWidgets.QFrame(self.frame_4)
        self.line_6.setGeometry(QtCore.QRect(560, 0, 20, 171))
        self.line_6.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_6.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_6.setObjectName("line_6")

        self.line_12 = QtWidgets.QFrame(self.frame_4)
        self.line_12.setGeometry(QtCore.QRect(240, 80, 461, 20))
        self.line_12.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_12.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_12.setObjectName("line_12")

        self.line_14 = QtWidgets.QFrame(self.frame_4)
        self.line_14.setGeometry(QtCore.QRect(800, 0, 20, 121))
        self.line_14.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_14.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_14.setObjectName("line_14")

        self.radioButton = QtWidgets.QRadioButton(self.frame_4)
        self.radioButton.setGeometry(QtCore.QRect(10, 140, 81, 20))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(85, 85, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(85, 85, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)
        brush = QtGui.QBrush(QtGui.QColor(85, 85, 255, 128))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.PlaceholderText, brush)
        brush = QtGui.QBrush(QtGui.QColor(85, 85, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(85, 85, 255))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)
        brush = QtGui.QBrush(QtGui.QColor(85, 85, 255, 128))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.PlaceholderText, brush)
        brush = QtGui.QBrush(QtGui.QColor(120, 120, 120))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)
        brush = QtGui.QBrush(QtGui.QColor(120, 120, 120))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0, 128))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.PlaceholderText, brush)
        self.radioButton.setPalette(palette)
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(8)
        font.setBold(True)
        font.setWeight(75)
        self.radioButton.setFont(font)
        self.radioButton.setAutoFillBackground(False)
        self.radioButton.setChecked(True)
        self.radioButton.setAutoExclusive(False)
        self.radioButton.setObjectName("radioButton")


        self.frame_3 = QtWidgets.QFrame(self.centralwidget)
        self.frame_3.setGeometry(QtCore.QRect(10, 430, 701, 71))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 254, 219))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 254, 219))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 254, 219))
        brush.setStyle(QtCore.Qt.SolidPattern)
        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)
        self.frame_3.setPalette(palette)
        self.frame_3.setAutoFillBackground(True)
        self.frame_3.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_3.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_3.setObjectName("frame_3")

        self.line_10 = QtWidgets.QFrame(self.frame_3)
        self.line_10.setGeometry(QtCore.QRect(800, 0, 16, 61))
        self.line_10.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_10.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_10.setObjectName("line_10")

        self.pushButton_7 = QtWidgets.QPushButton(self.frame_3)
        self.pushButton_7.setGeometry(QtCore.QRect(590, 20, 101, 41))
        icon7 = QtGui.QIcon()
        icon7.addPixmap(QtGui.QPixmap("Images/Exit.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_7.setIcon(icon7)
        self.pushButton_7.setObjectName("pushButton_7")

        self.label_10 = QtWidgets.QLabel(self.frame_3)
        self.label_10.setGeometry(QtCore.QRect(240, 0, 181, 61))
        self.label_10.setObjectName("label_10")

        self.label_23 = QtWidgets.QLabel(self.frame_3)
        self.label_23.setGeometry(QtCore.QRect(400, 0, 181, 61))
        self.label_23.setObjectName("label_23")

        self.label_2 = QtWidgets.QLabel(self.frame_3)
        self.label_2.setGeometry(QtCore.QRect(170, 10, 81, 61))
        self.label_2.setText("")
        self.label_2.setPixmap(QtGui.QPixmap("Images/IAG.gif"))
        self.label_2.setScaledContents(True)
        self.label_2.setObjectName("label_2")

        self.pushButton_6 = QtWidgets.QPushButton(self.frame_3)
        self.pushButton_6.setGeometry(QtCore.QRect(20, 20, 101, 41))
        icon8 = QtGui.QIcon()
        icon8.addPixmap(QtGui.QPixmap("Images/Back.gif"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.pushButton_6.setIcon(icon8)
        self.pushButton_6.setObjectName("pushButton_6")

        self.line_7 = QtWidgets.QFrame(self.frame_3)
        self.line_7.setGeometry(QtCore.QRect(140, 0, 20, 71))
        self.line_7.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_7.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_7.setObjectName("line_7")

        self.line_8 = QtWidgets.QFrame(self.frame_3)
        self.line_8.setGeometry(QtCore.QRect(405, 0, 20, 71))
        self.line_8.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_8.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_8.setObjectName("line_8")

        self.line_11 = QtWidgets.QFrame(self.frame_3)
        self.line_11.setGeometry(QtCore.QRect(560, 0, 20, 71))
        self.line_11.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_11.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_11.setObjectName("line_11")

        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        # Color and text formatting on Command Buttons
        self.pushButton.setStyleSheet("background-color: honeydew; color: blue")            # Text and Color of the Command Button (load File)
        self.pushButton_2.setStyleSheet("background-color: honeydew; color: blue")          # Text and Color of the Command Button (clean input)
        self.pushButton_3.setStyleSheet("background-color: silver; color: blue")            # Text and Color of the Command Button (Save Dir)
        self.pushButton_6.setStyleSheet("background-color: CornflowerBlue; color: white")   # Text and Color of the Command Button (Go Back)
        self.pushButton_7.setStyleSheet("background-color: burlywood; color: blue")         # Text and Color of the Command Button (Exit)
        self.pushButton_8.setStyleSheet("background-color: gold; color: blue")              # Text and Color of the Command Button (Plot Signal)

        # Variables globales de los filtros inicializadas a cero (0):
        FPasoBajoMin = 0           # Variable Tiempo inicial Min, para ser utilizada en el filtro Paso Bajo (Lowpass)
        FPasoBajoMax = 0           # Variable Tiempo Final Max, para ser utilizada en el filtro Paso Bajo (Lowpass)
        FPasoAltoMin = 0           # Variable Tiempo inicial Min, para ser utilizada en el filtro Paso Alto (Highpass)
        FPasoAltoMax = 0           # Variable Tiempo Final Max, para ser utilizada en el filtro Paso Alto (Highpass)
        FPasoBandMin = 0           # Variable Tiempo inicial Min, para ser utilizada en el filtro Paso Banda (Bandpass)
        FPasoBandMAx = 0           # Variable Tiempo Final Max, para ser utilizada en el filtro Paso Banda (Bandpass)
        FPasoStopMin = 0           # Variable Tiempo inicial Min, para ser utilizada en el filtro Surpime Banda  (Bandstop)
        FPasoStopMax = 0           # Variable Tiempo Final Max, para ser utilizada en el filtro Surpime Banda  (Bandstop)
        TFinal = 0                 # Variable para el tiempo final del corte.

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Cut and Save Seismic Signals - University of Granada (Ugr)"))

        self.label_3.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:10pt; font-style:italic; color:#aa0000;\">Load files and paths - save records:</span></p></body></html>"))
        self.label_5.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; font-style:italic; color:#142cc8;\">Seismic Record Path to Upload</span></p></body></html>"))
        self.label_6.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; font-style:italic; color:#142cc8;\">Seismic Record Path to Save</span></p></body></html>"))
        self.label_9.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-style:italic; color:#aa0000;\">Initial Time (s)</span></p></body></html>"))
        self.label_11.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-style:italic; color:#aa0000;\">End Time (s)</span></p></body></html>"))
        self.label_16.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; color:#610000;\">Trace number st(n):</span></p></body></html>"))
        self.label_17.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">By default: st(0)</span></p></body></html>"))
        self.label_18.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; font-style:italic; color:#00007f;\">By default = 4</span></p></body></html>"))
        self.label_19.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Filter Order</span></p></body></html>"))
        self.label_20.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Max (Hz):</span></p></body></html>"))
        self.label_21.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:7pt; font-weight:600; font-style:italic; color:#aa5500;\">Frec Min (Hz):</span></p></body></html>"))
        self.label_22.setText(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:6pt; font-weight:600; color:#0055ff;\">Frecuency (Hz)</span></p></body></html>"))

        # Texto en los botones de comandos
        self.pushButton.setText(_translate("MainWindow", " Load"))
        self.pushButton_2.setText(_translate("MainWindow", " Clean Inputs"))
        self.pushButton_3.setText(_translate("MainWindow", " Save Dir"))
        self.pushButton_6.setText(_translate("MainWindow", " Go Back"))
        self.pushButton_7.setText(_translate("MainWindow", " Exit"))
        self.pushButton_8.setText(_translate("MainWindow", " Plot Signal"))

        # Texto emergente (ToolTip) al poner el cursor en los botones de comandos
        self.pushButton.setToolTip(_translate("MainWindow", "Load Record"))
        self.pushButton_2.setToolTip(_translate("MainWindow", "Clean Inputs"))
        self.pushButton_3.setToolTip(_translate("MainWindow", "Save directory"))
        self.pushButton_6.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#aa0000;\">Go Back</span></p></body></html>"))
        self.pushButton_7.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#aa0000;\">Exit System</span></p></body></html>"))
        self.pushButton_8.setToolTip(_translate("MainWindow", "Plot Record"))

        # Elementos del comoBox
        self.groupBox_2.setTitle(_translate("MainWindow", "Filter type"))
        self.comboBox_2.setItemText(0, _translate("MainWindow", "Please select"))
        self.comboBox_2.setItemText(1, _translate("MainWindow", "Lowpass"))
        self.comboBox_2.setItemText(2, _translate("MainWindow", "Highpass"))
        self.comboBox_2.setItemText(3, _translate("MainWindow", "Bandpass"))
        self.comboBox_2.setItemText(4, _translate("MainWindow", "Bandstop"))

        # Validar para que solo se acepten números decimales "QDoubleValidator": Para "enteros", hay que colocar "QIntValidator"
        self.lineEdit.setValidator(QtGui.QDoubleValidator())            # Solo acepta números decimales en la caja de texto de tiempo inicial
        self.lineEdit_2.setValidator(QtGui.QDoubleValidator())          # Solo acepta números decimales en la caja de texto de tiempo final
        self.lineEdit_6.setValidator(QtGui.QDoubleValidator())          # Solo acepta números decimales en la caja de texto de Frecuencia del Filtro
        self.lineEdit_7.setValidator(QtGui.QDoubleValidator())          # Solo acepta números decimales en la caja de texto de Frecuencia máxima
        self.lineEdit_8.setValidator(QtGui.QDoubleValidator())          # Solo acepta números decimales en la caja de texto de Frecuencia mínima

        # El valor (1,999) Indica que se van a utilizar solo hasta 4 posiciones de enteros
        self.lineEdit_5.setValidator(QtGui.QIntValidator(1, 99))        # Solo acepta números enteros en la caja de texto de número de traza. Valor dos digitos
        self.lineEdit_9.setValidator(QtGui.QIntValidator(1, 99))        # Solo acepta números en la caja de texto de orden del Filtro. Valor dos digitos

        # Definición y texto del radioButton (Con tiempo = True)
        self.radioButton.setText(_translate("MainWindow", "With Time"))

        # Texto enriquecido (HTML) para la etiqueta que indica una advertencia
        self.label_10.setText(_translate("MainWindow", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:8pt; font-weight:400; font-style:normal;\">\n"
"<p align=\"center\" style=\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-weight:600;\">Warning</span><span style=\" font-size:7pt; font-weight:600; font-style:italic;\">: </span></p>\n"
"<p align=\"center\" style=\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:7pt; font-style:italic;\">Make sure that the upload directories </span></p>\n"
"<p align=\"center\" style=\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:7pt; font-style:italic;\">and storage are selected.</span></p></body></html>"))

        # Texto enriquecido (HTML) para la etiqueta que indica un mensaje para que el usuario espere al calculo del array de tiempo
        self.label_23.setText(_translate("MainWindow", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"     # After the calculation, the graph will be displayed
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:7pt; font-weight:400; font-style:normal;\">\n"
"<p align=\"center\" style=\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-weight:600;\">Wait: Time to plot</span><span style=\" font-size:7pt; font-weight:600; font-style:italic;\">: </span></p>\n"
"<p align=\"center\" style=\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:7pt; font-style:italic;\">can be long. After the calculation,</span></p>\n"
"<p align=\"center\" style=\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:7pt; font-style:italic;\"> the graph will be displayed.</span></p></body></html>"))


        # Command button actions, function calls
        self.pushButton.clicked.connect(self.abrir_archivo2)            # Call the function to upload file (Load File).
        self.pushButton_2.clicked.connect(self.limpiar_entradas)        # Calls the function to clean entries (Clean Entries).
        self.pushButton_3.clicked.connect(self.guardar)                 # Calls the function to save file (Save cut file).
        self.pushButton_6.clicked.connect(self.abrir_programa1)         # Call the function to return to the Home Screen (Go Back).
        self.pushButton_7.clicked.connect(self.Exit1)                   # Call the function to exit the System (Exit System).
        self.pushButton_8.clicked.connect(self.verificar2)              # Call the function to graph and the filter records (Filter).

        # Llamada a la funcion de acuerdo a la lista del ComboBox para el tipo de Filtro
        self.comboBox_2.activated.connect(self.verificar1)

        # The value (1,999) indicates that only up to 4 integer positions are to be used.
        self.lineEdit_9.setValidator(QtGui.QIntValidator(1, 99))        # Only accepts numbers in the Filter order text box. Two-digit value.
        self.lineEdit_5.setValidator(QtGui.QIntValidator(1, 99))        # Only accepts numbers in the Filter order text box. Two-digit value.

        # Enable and Disable text boxes initially
        self.lineEdit.setEnabled(True)                                  # Disable the Initial time Text box
        self.lineEdit_2.setEnabled(True)                                # Disable the End Time Text Box
        self.lineEdit_5.setEnabled(True)                                # Disable Trece No. st[0] Text box.
        self.lineEdit_6.setEnabled(False)                               # Deactivate the Frequency Text box.
        self.lineEdit_7.setEnabled(False)                               # Disables the maximum frequency text box. / (Max Time).
        self.lineEdit_8.setEnabled(False)                               # Disables the minimum frequency text box. / (Min. Time).
        self.lineEdit_9.setEnabled(False)                               # Deactivate the Filter Order Text box.

        self.lineEdit_5.setText("0")                                    # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.lineEdit_9.setText("4")                                    # Inicia contenido de caja de texto de orden de filtro = 4.

        self.comboBox_2.setEnabled(False)                               # disable comboBox

        self.radioButton.toggled.connect(self.onClicked)                # Llamada a la función para utilizar el radiobutton de acuerdo si se da clic o no


    def limpiar_entradas(self):                         # Dejar todo como al inicio

        msg = QMessageBox()
        msg.setIcon(QMessageBox.Question)
        msg.setWindowTitle("Clean all inputs.")
        msg.setText("Are you sure to delete all entries?")
        msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        msg.setDefaultButton(QMessageBox.Ok)                                    # By default, the focus is on the OK button
        returnValue = msg.exec()
        if returnValue == QMessageBox.Ok:                                       # If the answer is OK

            # Posiciona los ComoBox al inicio
            self.comboBox_2.setCurrentIndex(0)              # Posiciona en el primer Item (ComboBox de Tipo de Filtro = seleccione)
            plt.close()

            # Marca el radioButton como falso
            self.radioButton.setChecked(True)

            # Limpiar entradas Etiquetas y cajas de texto

            self.label_4.setText("")                        # Borra contenido etiqueta de Ruta de Archivo
            self.label_7.setText("")                        # Borra contenido etiqueta de Ruta de Guardar Archivo

            self.lineEdit.setText("")                       # Borra contenido de caja de texto de Initial Time.
            self.lineEdit_2.setText("")                     # Borra contenido de caja de texto de End Time.
            self.lineEdit_5.setText("")                     # Borra contenido de la caja de texto de Nº de Traza st[0].
            self.lineEdit_6.setText("")                     # Borra contenido de caja de texto de Frecuencia.
            self.lineEdit_7.setText("")                     # Borra contenido de caja de texto de Frecuencia Máxima.
            self.lineEdit_8.setText("")                     # Borra contenido de caja de texto de Frecuencia Mínima.

            self.lineEdit_5.setText("0")                    # Inicia contenido de caja de texto de Nº de Traza st[0].
            self.lineEdit_9.setText("4")                    # Inicia contenido de caja de texto de Orden del Filtro.

            # Habilitar y desabilitar cajas de texto de entradas
            self.lineEdit.setEnabled(True)                 # Desactiva la caja de Texto de Initial Time.
            self.lineEdit_2.setEnabled(True)               # Desactiva la caja de Texto de End Time.

            self.lineEdit_5.setEnabled(True)               # Desactiva la caja de Texto de Nº de Traza st[0].
            self.lineEdit_6.setEnabled(False)               # Desactiva la caja de Texto de Frecuencia.
            self.lineEdit_7.setEnabled(False)               # Desactiva la caja de texto de Frecuencia Máxima.
            self.lineEdit_8.setEnabled(False)               # Desactiva la caja de texto de Frecuencia Mínima.
            self.lineEdit_9.setEnabled(False)               # Desactiva la caja de texto de Orden del Filtro.

            plt.close()                                     # cierra el gráfico existente.

        else:
            pass

    """ Funciones que permiten la activación / desactivación de los cuadros de texto en los filtros  """

    def activacion1(self):                                              # Para Activar/Desactivar y limpieza en "Seleccion"

        plt.close()                                                     # cierra el gráfico existente

        # Marca el radioButton como falso
        self.radioButton.setChecked(True)

        # Limpiar entradas Etiquetas y cajas de texto

        self.label_4.setText("")                        # Borra contenido etiqueta de Ruta de Archivo
        self.label_7.setText("")                        # Borra contenido etiqueta de Ruta de Guardar Archivo

        self.lineEdit.setText("")                       # Borra contenido de caja de texto de Initial Time.
        self.lineEdit_2.setText("")                     # Borra contenido de caja de texto de End Time.
        self.lineEdit_5.setText("")                     # Borra contenido de la caja de texto de Nº de Traza st[0].
        self.lineEdit_6.setText("")                     # Borra contenido de caja de texto de Frecuencia.
        self.lineEdit_7.setText("")                     # Borra contenido de caja de texto de Frecuencia Máxima.
        self.lineEdit_8.setText("")                     # Borra contenido de caja de texto de Frecuencia Mínima.

        self.lineEdit_5.setText("0")                    # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.lineEdit_9.setText("4")                    # Inicia contenido de caja de texto de Orden del Filtro.

        # Habilitar y desabilitar cajas de texto de entradas
        self.lineEdit.setEnabled(True)                 # Desactiva la caja de Texto de Initial Time.
        self.lineEdit_2.setEnabled(True)               # Desactiva la caja de Texto de End Time.

        self.lineEdit_5.setEnabled(True)               # Desactiva la caja de Texto de Nº de Traza st[0].
        self.lineEdit_6.setEnabled(False)               # Desactiva la caja de Texto de Frecuencia.
        self.lineEdit_7.setEnabled(False)               # Desactiva la caja de texto de Frecuencia Máxima.
        self.lineEdit_8.setEnabled(False)               # Desactiva la caja de texto de Frecuencia Mínima.
        self.lineEdit_9.setEnabled(False)               # Desactiva la caja de texto de Orden del Filtro.

        plt.close()                                     # cierra el gráfico existente

    def activacion2(self):                              # Para Activar/Desactivar y limpieza en Lowpass y Highpass

        plt.close()                                     # cierra el gráfico existente

        # Limpiar entradas Etiquetas y cajas de texto
        self.lineEdit.setText("")                       # Borra contenido de caja de texto de Initial Time.
        self.lineEdit_2.setText("")                     # Borra contenido de caja de texto de End Time.
        self.lineEdit_5.setText("")                     # Borra contenido de la caja de texto de Nº de Traza st[0].
        self.lineEdit_6.setText("")                     # Borra contenido de caja de texto de Frecuencia.
        self.lineEdit_7.setText("")                     # Borra contenido de caja de texto de Frecuencia Máxima.
        self.lineEdit_8.setText("")                     # Borra contenido de caja de texto de Frecuencia Mínima.

        self.lineEdit_5.setText("0")                    # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.lineEdit_9.setText("4")                    # Inicia contenido de caja de texto de Orden del Filtro.

        # Activa/Desactiva cajas de texto
        self.lineEdit.setEnabled(False)                 # Desactiva la caja de Texto de Initial Time.
        self.lineEdit_2.setEnabled(False)               # Desactiva la caja de Texto de End Time.

        self.lineEdit_5.setEnabled(True)                # Activa la caja de Texto de Nº de Traza st[0].
        self.lineEdit_6.setEnabled(True)                # Activa la caja de Texto de Frecuencia.
        self.lineEdit_7.setEnabled(False)               # Desactiva la caja de texto de Frecuencia Máxima.
        self.lineEdit_8.setEnabled(False)               # Desactiva la caja de texto de Frecuencia Mínima.
        self.lineEdit_9.setEnabled(True)                # Activa la caja de texto de Orden del Filtro.

        plt.close()                                     # cierra el gráfico existente

    def activacion3(self):                              # Para Activar/Desactivar y limpieza en Check box True

        plt.close()                                     # cierra el gráfico existente

        self.lineEdit.setText("")                       # Borra contenido de caja de texto de Initial Time.
        self.lineEdit_2.setText("")                     # Borra contenido de caja de texto de End Time.
        self.lineEdit_5.setText("")                     # Borra contenido de la caja de texto de Nº de Traza st[0].
        self.lineEdit_6.setText("")                     # Borra contenido de caja de texto de Frecuencia.
        self.lineEdit_7.setText("")                     # Borra contenido de caja de texto de Frecuencia Máxima.
        self.lineEdit_8.setText("")                     # Borra contenido de caja de texto de Frecuencia Mínima.

        self.lineEdit_5.setText("0")                    # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.lineEdit_9.setText("4")                    # Inicia contenido de caja de texto de Orden del Filtro.

        # Activa/Desactiva cajas de texto
        self.lineEdit.setEnabled(True)                  # Activa la caja de Texto de Initial Time.
        self.lineEdit_2.setEnabled(True)                # Activa la caja de Texto de End Time.

        self.lineEdit_5.setEnabled(True)                # Activa la caja de Texto de Nº de Traza st[0].
        self.lineEdit_6.setEnabled(False)               # Desactiva la caja de Texto de Frecuencia.
        self.lineEdit_7.setEnabled(False)               # Desactiva la caja de texto de Frecuencia Máxima.
        self.lineEdit_8.setEnabled(False)               # Desactiva la caja de texto de Frecuencia Mínima.
        self.lineEdit_9.setEnabled(False)               # Desactiva la caja de texto de Orden del Filtro.

        plt.close()                                     # cierra el gráfico existente

    def activacion3b(self):                             # Para Activar/Desactivar y limpieza en Check box False

        plt.close()                                     # cierra el gráfico existente

        self.lineEdit.setText("")                       # Borra contenido de caja de texto de Initial Time.
        self.lineEdit_2.setText("")                     # Borra contenido de caja de texto de End Time.
        self.lineEdit_5.setText("")                     # Borra contenido de la caja de texto de Nº de Traza st[0].
        self.lineEdit_6.setText("")                     # Borra contenido de caja de texto de Frecuencia.
        self.lineEdit_7.setText("")                     # Borra contenido de caja de texto de Frecuencia Máxima.
        self.lineEdit_8.setText("")                     # Borra contenido de caja de texto de Frecuencia Mínima.

        self.lineEdit_5.setText("0")                    # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.lineEdit_9.setText("4")                    # Inicia contenido de caja de texto de Orden del Filtro.

        # Activa/Desactiva cajas de texto
        self.lineEdit.setEnabled(False)                 # Activa la caja de Texto de Initial Time.
        self.lineEdit_2.setEnabled(False)               # Activa la caja de Texto de End Time.

        self.lineEdit_5.setEnabled(False)               # Activa la caja de Texto de Nº de Traza st[0].
        self.lineEdit_6.setEnabled(False)               # Desactiva la caja de Texto de Frecuencia.
        self.lineEdit_7.setEnabled(False)               # Desactiva la caja de texto de Frecuencia Máxima.
        self.lineEdit_8.setEnabled(False)               # Desactiva la caja de texto de Frecuencia Mínima.
        self.lineEdit_9.setEnabled(False)               # Desactiva la caja de texto de Orden del Filtro.

        plt.close()                                     # cierra el gráfico existente

    def activacion4(self):                              # Para Activar/Desactivar y limpieza en Bandpass y Stopband

        plt.close()                                     # cierra el gráfico existente

        # Limpiar entradas Etiquetas y cajas de texto
        self.lineEdit.setText("")                       # Borra contenido de caja de texto de Initial Time.
        self.lineEdit_2.setText("")                     # Borra contenido de caja de texto de End Time.
        self.lineEdit_5.setText("")                     # Borra contenido de la caja de texto de Nº de Traza st[0].
        self.lineEdit_6.setText("")                     # Borra contenido de caja de texto de Frecuencia.
        self.lineEdit_7.setText("")                     # Borra contenido de caja de texto de Frecuencia Máxima.
        self.lineEdit_8.setText("")                     # Borra contenido de caja de texto de Frecuencia Mínima.

        self.lineEdit_5.setText("0")                    # Inicia contenido de caja de texto de Nº de Traza st[0].
        self.lineEdit_9.setText("4")                    # Inicia contenido de caja de texto de Orden del Filtro.

        # Activa/Desactiva cajas de texto
        self.lineEdit.setEnabled(False)                 # Desactiva la caja de Texto de Initial Time.
        self.lineEdit_2.setEnabled(False)               # Desactiva la caja de Texto de End Time.

        self.lineEdit_5.setEnabled(True)                # Activa la caja de Texto de Nº de Traza st[0].
        self.lineEdit_6.setEnabled(False)               # Desactiva la caja de Texto de Frecuencia.
        self.lineEdit_7.setEnabled(True)                # Activa la caja de texto de Frecuencia Máxima.
        self.lineEdit_8.setEnabled(True)                # Activa la caja de texto de Frecuencia Mínima.
        self.lineEdit_9.setEnabled(True)                # Activa la caja de texto de Orden del Filtro.


    def onClicked(self):            # Funcion para habilitar y desabilitar el comboBox mediante el radioButton

        if self.radioButton.isChecked() == True:
            self.activacion3()                           # llamada a la función para activar desactivar cuando el radio button es True.
            self.comboBox_2.setEnabled(False)            # disable comboBox

            #print("El radiobutton es Verdadero, ComoboBox desabilitado Utilizar tiempo inicio y final")
        else:
            self.activacion3b()                          # llamada a la función para activar desactivar cuando el radio button es True.
            self.comboBox_2.setEnabled(True)             # enable comboBox

            #print('El radiobutton es falso, ComboBox habilitado Utilizar el comboBox con los filtros')


    def abrir_archivo2(self):                           # Function, to search and load the records according to the format

            if sistema == "Windows":                    # Si el sistema operativo es Windows
                self.archivo_abierto=filedialog.askopenfilename(initialdir = "/",
                    title = "Please, select file",filetypes = (("All Files","*.*"),
                    ("SAC Files","*.sac"),
                    ('MSEED Files','*.mseed'),
                    ('GSE2 Files','*.gse2'),
                    ('WAV Files','*.wav'),
                    ('Kinemetrics Files','*.evt')))

                self.ruta = Path(self.archivo_abierto)
                self.ruta2 = self.ruta.joinpath(self.ruta).resolve()

                font=QtGui.QFont()
                font.setFamily("Times New Roman")
                font.setPointSize(8)
                font.setBold(False)
                font.setItalic(False)
                font.setWeight(60)
                self.label_4.setFont(font)                                      # Printing using text format.
                self.label_4.setText(self.archivo_abierto)                      # Printing on the file path label.

            else:                                       # En caso de que el sistema operativo sea diferente a Windows (Linux, Mac)
                self.archivo_abierto=filedialog.askopenfilename(initialdir = "/",
                    title = "Please, select file",filetypes = (("All Files","*.*"),
                    ("SAC Files","*.sac"),
                    ('MSEED Files','*.mseed'),
                    ('GSE2 Files','*.gse2'),
                    ('WAV Files','*.wav'),
                    ('Kinemetrics Files','*.evt')))

                self.ruta = Path(self.archivo_abierto)
                self.ruta2 = self.ruta.joinpath(self.ruta).resolve()

                font=QtGui.QFont()
                font.setFamily("Times New Roman")
                font.setPointSize(8)
                font.setBold(False)
                font.setItalic(False)
                font.setWeight(60)
                self.label_4.setFont(font)                                      # Printing using text format.
                self.label_4.setText(self.archivo_abierto)                      # Printing on the file path label.


    def guardar(self):                                                      # Función para búsqueda de registro de acuerdo al formato
        if sistema == "Windows":                                            # Si el sistema operativo es Windows
            self.archivo_abierto2=filedialog.askdirectory(initialdir = "/",
              title = "Please, Select Folder")

            self.ruta3 = Path(self.archivo_abierto2)
            self.ruta4 = self.ruta3.joinpath(self.ruta3).resolve()

            font=QtGui.QFont()
            font.setFamily("Times New Roman")
            font.setPointSize(8)
            font.setBold(False)
            font.setItalic(False)
            font.setWeight(60)
            self.label_7.setFont(font)                                      # Impresion mediante el formato de texto
            self.label_7.setText(self.archivo_abierto2 + "/")               # Impresión en la eiqueta de la ruta del fichero

        else:                                                               # If the system is Linux or Mac
            self.archivo_abierto2=filedialog.askdirectory(initialdir = "/",
              title = "Please, Select Folder")

            self.ruta3 = Path(self.archivo_abierto2)
            self.ruta4 = self.ruta3.joinpath(self.ruta3).resolve()
            # Si se desea conocer la extensión del fichero : print("La extensión del Registro es: ", self.ruta4.suffix)

            font=QtGui.QFont()
            font.setFamily("Times New Roman")
            font.setPointSize(8)
            font.setBold(False)
            font.setItalic(False)
            font.setWeight(60)
            self.label_7.setFont(font)                                      # Impresion mediante el formato de texto
            self.label_7.setText(self.archivo_abierto2 + "/")               # Impresión en la eiqueta de la ruta del fichero


    """ Function, which loads the functions for analysis with filters   """

    def verificar1(self):                                                       # Function to validate entries and plot Filters.

            index1 = self.comboBox_2.currentIndex()                             # Reading the ComboBox index.

            if (0 == index1):                                                   # En caso de que el índice del combo sea 0, "Seleccione"
                # Posiciona los ComoBox al inicio
                self.activacion1()                                              # Llamada a la función de limpieza y Activacion/Desactivación
            elif (1 == index1):
                self.activacion2()                                           # Lowpass filter.
            elif (2 == index1):
                self.activacion2()                                           # Highpass filter.
            elif (3 == index1):
                self.activacion4()                                           # Bandpass filter.
            elif (4 == index1):
                self.activacion4()                                           # Stopband filter.
            else:
                pass

    def verificar2(self):                                   # Función para validar entradas y graficar con tiempo inicial/final y filtro del evento

        if self.radioButton.isChecked() == True:            # En caso de estar activo el radiobutton, se grafica con tiempo inicial y final del evento

            self.comboBox_2.setCurrentIndex(0)              # Posiciona en el primer Item (seleccione)
            self.comboBox_2.setEnabled(False)               # desactiva el comboBox
            plt.close()                                     # cierra el gráfico existente

            try:

                # Verificar que las cajas de texto implicadas no estén vacías
                if not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Trace No. Empty")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Initial Time Empty")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.lineEdit_2.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("End Time Empty")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                elif not self.label_4.text():
                    MensCombo6 = QMessageBox()
                    MensCombo6.setIcon(QMessageBox.Warning)
                    MensCombo6.setWindowTitle("Path and file name Empty")
                    MensCombo6.setText("Please, enter a valid Value")
                    returnValue = MensCombo6.exec()

                elif not self.label_7.text():
                    MensCombo7 = QMessageBox()
                    MensCombo7.setIcon(QMessageBox.Warning)
                    MensCombo7.setWindowTitle("Path and Directory name Empty")
                    MensCombo7.setText("Please, enter a valid Value")
                    returnValue = MensCombo7.exec()

                else:

                    #plt.close()                                                 # Close the existing chart.

                    archivoFil1 = (self.label_4.text())                         # Lectura etiqueta del Record
                    archivoFil2 = (self.label_7.text())                         # Lectura etiqueta del Directorio

                    head, tail = os.path.split(self.archivo_abierto)

                    root, extension = os.path.splitext(tail)

                    TimeMin = (self.lineEdit.text())                            # Lectura del tiempo inicial
                    TimeMax = (self.lineEdit_2.text())                          # Lectura del tiempo final

                    TimeMin2 = int(TimeMin)                                     # Convierte el valor string del tiempo inicial a entero
                    TimeMax2 = int(TimeMax)                                     # Convierte el valor string del tiempo final a entero

                    st  = obspy.read(archivoFil1)                               # Lectura archivo de acuerdo al formato

                    # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                    NTraza = (self.lineEdit_5.text())                           # Lectura del contenido de la caja de texto Nº Traza st[0]
                    Ntraza2 = int(NTraza)                                       # Convierte el valor del Nº de Traza a entero
                    tr = st[Ntraza2]                                            # Asigna el número de traza indicado al Stream para tratamiento del registro

                    tr.stats.station
                    tr_filt = tr.copy()
                    s = len(tr)

                    tr_filt = tr.copy()

                    # Uso del filtro de tipo "pasobanda", "bandpass"
                    tr_filt.filter('bandpass', freqmin=3, freqmax=15, corners=4, zerophase=True) # Donde corners = orden del filtro
                    # Donde corners = orden del filtro, de orden 2
                    #tr_filt.filter('lowpass', freq=frec1, corners=2, zerophase=True)

                    #☼ Calculo del vector de tiempo
                    t = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)

                    # Para calculo del tiempo de corte
                    t0 = st[0].stats.starttime                                  # Tiempo inicial de la señal

                    t2 = t0 + TimeMin2*1                                        # Tiempo de Inicio para el corte del evento
                    t3 = t0 + TimeMax2*1                                        # Tiempo Final para el corte del evento

                    st[0].trim(t2,t3)                                           # Se asigna el valor de la señal a los tiempos designados, inicial y final

                    t4 = st[0]

                    # Como hay probabilidad que el vector de tiempo generado sea más largo que el de los datos de la traza
                    # Se procede a recortarlo con el siguiente código
                    while (len(t) > len(tr.data)):
                        t = list(t)
                        last_object = len(t) - 1
                        del t[last_object]
                        t = np.array(t)

                    # Gráfica del registro cortado
                    plt.plot(t, t4, 'b')
                    plt.ylabel('Counts', color ="blue")
                    plt.xlabel('Time [s]', color ="red")
                    plt.title(u'Cut record', color ="darkgreen")  # Se pone un título
                    plt.suptitle("Record : %s " % tr.stats.starttime, color ="red")
                    plt.grid()              # presenta la cuadricula en el grafico
                    plt.show()              # Visualiza el gráfico

                    # Ventana de dialogo (MessageBox) para guardar el corte por formatos SAC y MSEED
                    dialog = QMessageBox()
                    dialog.setWindowTitle("Save the event cut Record")
                    dialog.setText("Do you want to save MSEED or SAC Format?, CANCEL = Close all graphics")
                    # Se agregan los botones de comandos y se personalizan
                    dialog.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel | QMessageBox.No)
                    dialog.button(QMessageBox.Ok).setText("MSEED")
                    dialog.button(QMessageBox.Cancel).setText("CANCEL")
                    dialog.button(QMessageBox.No).setText("SAC")
                    # Se establece el tipo de icono a presentar
                    dialog.setIcon(QMessageBox.Question)

                    # Se ejecuta el dialog y se captura el resultado
                    returnValue = dialog.exec_()
                    # Ciclo en el que se comprueba que boton de comando ha sido ejecutado
                    if returnValue == QMessageBox.Ok:       # En caso de que la selección sea grabar con formato MSEED
                        F1 = (root + '.MSEED')
                        F2 = (archivoFil2 + F1)
                        st[0].write( filename= (F2), format="MSEED")

                        showinfo(title = "File MSEED successfully created", message = "Successfully created record.\n\n")
                        plt.close()

                    elif returnValue == QMessageBox.No:     # En caso de que la selección sea grabar con formato SAC
                        F3 = (root + '.SAC')
                        F4 = (archivoFil2 + F3)
                        st[0].write( filename= (F4), format="SAC")
                        showinfo(title = "File SAC successfully created", message = "Successfully created record.\n\n")
                        plt.close()

                    else:                                   # En caso de que la selñeccion sea cancelar
                        showinfo(title = "Close all graphics", message = "The plot windows close.\n\n")
                        plt.close()

            except:                                         # Validacion de cualquier posibilidad de error, presenta una ventana de dialogo
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setWindowTitle("Save the event cut Record")
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Record File")
                returnValue = msgBox.exec()
                pass

        else:                                               # El radio button se encuentra a falso es decir, se utiliza el filtro

            self.comboBox_2.setEnabled(True)                # activa el comboBox y presenta la selección de acuerdo al tipo de filtro

            index1 = self.comboBox_2.currentIndex()         # Lectura del indice del ComboBox para seleccionar el tipo de filtro

            if (1 == index1):
                self.filtropasobajo()                       # Llamada a la función para el tipo de filtro pasobajo (Lowpass)
            elif (2 == index1):
                self.filtropasoalto()                       # Llamada a la función para el tipo de filtro pasoalto (Highpass)
            elif (3 == index1):
                self.filtropasabanda()                      # Llamada a la función para el tipo de filtro pasobanda (Bandpass)
            elif (4 == index1):
                self.filtrobandstop()                       # Llamada a la función para el tipo de filtro detienebanda (Bandstop)
            else:
                pass


    """  *** Functions to perform analysis with filters (1-4) ***     """

    def filtropasobajo(self):                                               # 1.- Function to execute the Lowpass filter

            plt.close()

            try:

                # Verify that the text box is not empty
                if not self.lineEdit_6.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty Frequency")
                    MensCombo1.setText("Please, enter a valid Value")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_9.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty Filter Order")
                    MensCombo2.setText("Please, enter a valid Value")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Trace No. Empty")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.label_4.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Path and file name Empty")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.label_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Path and Directory name Empty")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                else:
                    # Filtering with a lowpass.
                    plt.close()                                # Close the existing chart.
                    global FPasoBajoMin                        # Se llama a la variable global Tiempo inicial Min en la función
                    global FPasoBajoMax                        # Se llama a la variable global Tiempo Final Max en la función

                    # Lineas para determinar los elementos de la cabecera del archivo, para luego utilizarlas en guardar el registro resultante
                    head, tail = os.path.split(self.archivo_abierto)
                    root, extension = os.path.splitext(tail)

                    archivoFil1 = (self.label_4.text())                         # Lectura etiqueta del Record

                    frec1 = (self.lineEdit_6.text())                            # Lectura etiqueta de la Frecuencia
                    orden1 = (self.lineEdit_9.text())                           # Lectura del orden del Filter

                    st  = obspy.read(archivoFil1)                               # Lectura archivo de acuerdo al formato

                    # Convertir a flotante el valor string de la caja de texto
                    frec2=float(frec1)                                          # Convierte el valor string de Frecuencia a flotante
                    orden2=int(orden1)                                          # Convierte el valor string del orden del filtro a entero

                    # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                    NTraza = (self.lineEdit_5.text())                           # Lectura del contenido de la caja de texto Nº Traza st[0]
                    Ntraza2 = int(NTraza)                                       # Convierte el valor del Nº de Traza a entero
                    tr = st[Ntraza2]                                            # Asigna el número de traza indicado al Stream para tratamiento del registro

                    # Realizar una copia para el uso del filtro
                    tr.stats.station
                    tr_filt = tr.copy()
                    s = len(tr)
                    # Calculo del tipo de filtro con sus respectivos parametros
                    tr_filt.filter('lowpass', freq=frec2, corners=orden2, zerophase=True)

                    # Calculo del vector de tiempo de acuerdo al registro
                    t = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)

                    t0 = st[0].stats.starttime

                    # Debido a que el velor del tiempo calculado puede diferir del valor del vector de tipo de la traza
                    # Se realiza un calculo de ajuste para que sean iguales de acuerdo al siguiente codigo

                    while (len(t) > len(tr.data)):
                        t = list(t)
                        last_object = len(t) - 1
                        del t[last_object]
                        t = np.array(t)

                    fig, (ax1, ax2) = plt.subplots(2, 1)

                    ax1.plot(t, tr_filt.data, 'k')    # Donde 'k' es el color = black
                    plt.ylabel('Lowpass Filtered Data', color ="blue")
                    plt.xlabel('Time [s]', color ="red")
                    plt.suptitle("Record : %s " % tr.stats.starttime, color ="red")
                    ax1.grid()                                              # presenta la cuadricula en el grafico 1
                    ax2.grid()                                              # presenta la cuadricula en el grafico 2

                    line2, = ax2.plot([], [])

                    # Funcion onselect para poder seleccionar el area de corte en la grafica
                    def onselect(xmin, xmax):

                        # asignación de las variables globales que seran utilizadas en otras funciones
                        global FPasoBajoMin
                        global FPasoBajoMax
                        global TFinal

                        indmin, indmax = np.searchsorted(t, (xmin, xmax))
                        indmax = min(len(t) - 1, indmax)

                        region_x = t[indmin:indmax]
                        region_y = tr.data[indmin:indmax]

                        if len(region_x) >= 2:
                            line2.set_data(region_x, region_y)
                            ax2.set_xlim(region_x[0], region_x[-1])
                            ax2.set_ylim(region_y.min(), region_y.max())
                            fig.canvas.draw_idle()

                            FPasoBajoMin = xmin     # Asigna a la variable global el valor del tiempo inicial de corte
                            FPasoBajoMax = xmax     # Asigna a la variable global el valor del tiempo final de corte

                            # Valores para el calculo del intervalo de corte
                            t0 = st[0].stats.starttime                      # Tiempo inicial de la señal
                            t2 = t0 + FPasoBajoMin*1                        # Tiempo de Inicio para el corte del evento
                            t3 = t0 + FPasoBajoMax*1                        # Tiempo Final para el corte del evento
                            t4 = st[0].trim(t2,t3)                          # Tiempo de recorte inicial y final

                            TFinal = t4                     # Una vez calculado el tiempo de recorte se Asigna a la variable global el valor del corte del evento

                            self.DialogWindows()            # llamada a la función del cuadro de dialogo para guardar el recorte de acuerdo al formato

                    self.span = SpanSelector( ax1, onselect, 'horizontal', span_stays=True, useblit=True,
                            rectprops=dict(alpha=0.5, facecolor="tab:blue"),
                            interactive=True, drag_from_anywhere=True)

                    plt.show()                              # Hasta aquí se presenta la grafica despues de los calculos




            except:                 # En caso de existir algun error se presenta esta caja de dialogo
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Record File")
                returnValue = msgBox.exec()
                pass


    def filtropasoalto(self):                                               # 2.- Function to execute the Highpass filter

            plt.close()

            try:

                # Verify that the text box is not empty
                if not self.lineEdit_6.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty Frequency")
                    MensCombo1.setText("Please, enter a valid Value")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_9.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty Filter Order")
                    MensCombo2.setText("Please, enter a valid Value")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_5.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Trace No. Empty")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.label_4.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Path and file name Empty")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.label_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Path and Directory name Empty")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                else:
                    # Filtering with a highpass.

                    plt.close()                                # Close the existing chart.
                    global FPasoBajoMin                        # Se llama a la variable global Tiempo inicial Min en la función
                    global FPasoBajoMax                        # Se llama a la variable global Tiempo Final Max en la función

                    # Lineas para determinar los elementos de la cabecera del archivo, para luego utilizarlas en guardar el registro resultante
                    head, tail = os.path.split(self.archivo_abierto)
                    root, extension = os.path.splitext(tail)

                    archivoFil1 = (self.label_4.text())                         # Lectura etiqueta del Record

                    frec1 = (self.lineEdit_6.text())                            # Lectura etiqueta de la Frecuencia
                    orden1 = (self.lineEdit_9.text())                           # Lectura del orden del Filter

                    st  = obspy.read(archivoFil1)                               # Lectura archivo de acuerdo al formato

                    # Convertir a flotante el valor string de la caja de texto
                    frec2=float(frec1)                                          # Convierte el valor string de Frecuencia a flotante
                    orden2=int(orden1)                                          # Convierte el valor string del orden del filtro a entero

                    # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                    NTraza = (self.lineEdit_5.text())                           # Lectura del contenido de la caja de texto Nº Traza st[0]
                    Ntraza2 = int(NTraza)                                       # Convierte el valor del Nº de Traza a entero
                    tr = st[Ntraza2]                                            # Asigna el número de traza indicado al Stream para tratamiento del registro

                    # Realizar una copia para el uso del filtro
                    tr.stats.station
                    tr_filt = tr.copy()
                    s = len(tr)
                    # Calculo del tipo de filtro con sus respectivos parametros
                    tr_filt.filter('highpass', freq=frec2, corners=orden2, zerophase=True)

                    # Calculo del vector de tiempo de acuerdo al registro
                    t = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)

                    t0 = st[0].stats.starttime

                    # Debido a que el velor del tiempo calculado puede diferir del valor del vector de tipo de la traza
                    # Se realiza un calculo de ajuste para que sean iguales de acuerdo al siguiente codigo

                    while (len(t) > len(tr.data)):
                        t = list(t)
                        last_object = len(t) - 1
                        del t[last_object]
                        t = np.array(t)

                    fig, (ax1, ax2) = plt.subplots(2, 1)

                    ax1.plot(t, tr_filt.data, 'k')    # Donde 'k' es el color = black
                    plt.ylabel('Highpass Filtered Data', color ="blue")
                    plt.xlabel('Time [s]', color ="red")
                    plt.suptitle("Record : %s " % tr.stats.starttime, color ="red")
                    ax1.grid()                                              # presenta la cuadricula en el grafico 1
                    ax2.grid()                                              # presenta la cuadricula en el grafico 2

                    line2, = ax2.plot([], [])

                    # Funcion onselect para poder seleccionar el area de corte en la grafica
                    def onselect(xmin, xmax):

                        # asignación de las variables globales que seran utilizadas en otras funciones
                        global FPasoBajoMin
                        global FPasoBajoMax
                        global TFinal

                        indmin, indmax = np.searchsorted(t, (xmin, xmax))
                        indmax = min(len(t) - 1, indmax)

                        region_x = t[indmin:indmax]
                        region_y = tr.data[indmin:indmax]

                        if len(region_x) >= 2:
                            line2.set_data(region_x, region_y)
                            ax2.set_xlim(region_x[0], region_x[-1])
                            ax2.set_ylim(region_y.min(), region_y.max())
                            fig.canvas.draw_idle()

                            FPasoBajoMin = xmin     # Asigna a la variable global el valor del tiempo inicial de corte
                            FPasoBajoMax = xmax     # Asigna a la variable global el valor del tiempo final de corte

                            # Valores para el calculo del intervalo de corte
                            t0 = st[0].stats.starttime                      # Tiempo inicial de la señal
                            t2 = t0 + FPasoBajoMin*1                        # Tiempo de Inicio para el corte del evento
                            t3 = t0 + FPasoBajoMax*1                        # Tiempo Final para el corte del evento
                            t4 = st[0].trim(t2,t3)                          # Tiempo de recorte inicial y final

                            TFinal = t4                     # Una vez calculado el tiempo de recorte se Asigna a la variable global el valor del corte del evento

                            self.DialogWindows()            # llamada a la función del cuadro de dialogo para guardar el recorte de acuerdo al formato

                    self.span = SpanSelector( ax1, onselect, 'horizontal', span_stays=True, useblit=True,
                            rectprops=dict(alpha=0.5, facecolor="tab:blue"),
                            interactive=True, drag_from_anywhere=True)

                    plt.show()                              # Hasta aquí se presenta la grafica despues de los calculos


            except:                 # En caso de existir algun error se presenta esta caja de dialogo
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Record File")
                returnValue = msgBox.exec()
                pass


    def filtropasabanda(self):                                               # 3.- Function to execute the Bandpass filter

            plt.close()

            try:

                # Verify that the text box is not empty
                if not self.lineEdit_8.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty Minimum frequency")
                    MensCombo1.setText("Please, enter a valid Value")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_7.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty Maximum frequency")
                    MensCombo2.setText("Please, enter a valid Value")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_9.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Filter Order")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_5.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Trace No. Empty")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.label_4.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Path and file name Empty")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.label_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Path and Directory name Empty")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                else:
                    # Filtering with a Bandpass.

                    plt.close()                                # Close the existing chart.
                    global FPasoBajoMin                        # Se llama a la variable global Tiempo inicial Min en la función
                    global FPasoBajoMax                        # Se llama a la variable global Tiempo Final Max en la función

                    # Lineas para determinar los elementos de la cabecera del archivo, para luego utilizarlas en guardar el registro resultante
                    head, tail = os.path.split(self.archivo_abierto)
                    root, extension = os.path.splitext(tail)

                    archivoFil1 = (self.label_4.text())                         # Lectura etiqueta del Record

                    frecMax = (self.lineEdit_7.text())                          # Lectura etiqueta de Frec. Max.
                    frecM = (self.lineEdit_8.text())                            # Lectura etiqueta de Frec. Min.
                    orden1 = (self.lineEdit_9.text())                           # Lectura del orden del Filter

                    st  = obspy.read(archivoFil1)                               # Lectura archivo de acuerdo al formato

                    # Convertir a flotante el valor string de la caja de texto
                    frec7=float(frecM)                                          # Convierte a flotante el valor de la Frec. Min.
                    frec8=float(frecMax)                                        # Convierte a flotante el valor de la Frec. Max.
                    orden2=int(orden1)                                          # Convierte el valor string del orden del filtro a entero

                    # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                    NTraza = (self.lineEdit_5.text())                           # Lectura del contenido de la caja de texto Nº Traza st[0]
                    Ntraza2 = int(NTraza)                                       # Convierte el valor del Nº de Traza a entero
                    tr = st[Ntraza2]                                            # Asigna el número de traza indicado al Stream para tratamiento del registro

                    # Realizar una copia para el uso del filtro
                    tr.stats.station
                    tr_filt = tr.copy()
                    s = len(tr)
                    # Calculo del tipo de filtro con sus respectivos parametros
                    tr_filt.filter('bandpass', freqmin=frec7, freqmax=frec8, corners=orden2, zerophase=True)

                    # Calculo del vector de tiempo de acuerdo al registro
                    t = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)

                    t0 = st[0].stats.starttime

                    # Debido a que el velor del tiempo calculado puede diferir del valor del vector de tipo de la traza
                    # Se realiza un calculo de ajuste para que sean iguales de acuerdo al siguiente codigo

                    while (len(t) > len(tr.data)):
                        t = list(t)
                        last_object = len(t) - 1
                        del t[last_object]
                        t = np.array(t)

                    fig, (ax1, ax2) = plt.subplots(2, 1)

                    ax1.plot(t, tr_filt.data, 'k')    # Donde 'k' es el color = black
                    plt.ylabel('Bandpass Filtered Data', color ="blue")
                    plt.xlabel('Time [s]', color ="red")
                    plt.suptitle("Record : %s " % tr.stats.starttime, color ="red")
                    ax1.grid()                                              # presenta la cuadricula en el grafico 1
                    ax2.grid()                                              # presenta la cuadricula en el grafico 2

                    line2, = ax2.plot([], [])

                    # Funcion onselect para poder seleccionar el area de corte en la grafica
                    def onselect(xmin, xmax):

                        # asignación de las variables globales que seran utilizadas en otras funciones
                        global FPasoBajoMin
                        global FPasoBajoMax
                        global TFinal

                        indmin, indmax = np.searchsorted(t, (xmin, xmax))
                        indmax = min(len(t) - 1, indmax)

                        region_x = t[indmin:indmax]
                        region_y = tr.data[indmin:indmax]

                        if len(region_x) >= 2:
                            line2.set_data(region_x, region_y)
                            ax2.set_xlim(region_x[0], region_x[-1])
                            ax2.set_ylim(region_y.min(), region_y.max())
                            fig.canvas.draw_idle()

                            FPasoBajoMin = xmin     # Asigna a la variable global el valor del tiempo inicial de corte
                            FPasoBajoMax = xmax     # Asigna a la variable global el valor del tiempo final de corte

                            # Valores para el calculo del intervalo de corte
                            t0 = st[0].stats.starttime                      # Tiempo inicial de la señal
                            t2 = t0 + FPasoBajoMin*1                        # Tiempo de Inicio para el corte del evento
                            t3 = t0 + FPasoBajoMax*1                        # Tiempo Final para el corte del evento
                            t4 = st[0].trim(t2,t3)                          # Tiempo de recorte inicial y final

                            TFinal = t4                     # Una vez calculado el tiempo de recorte se Asigna a la variable global el valor del corte del evento

                            self.DialogWindows()            # llamada a la función del cuadro de dialogo para guardar el recorte de acuerdo al formato

                    self.span = SpanSelector( ax1, onselect, 'horizontal', span_stays=True, useblit=True,
                            rectprops=dict(alpha=0.5, facecolor="tab:blue"),
                            interactive=True, drag_from_anywhere=True)

                    plt.show()                              # Hasta aquí se presenta la grafica despues de los calculos


            except:                 # En caso de existir algun error se presenta esta caja de dialogo
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Record File")
                returnValue = msgBox.exec()
                pass


    def filtrobandstop(self):                                               # 5.- Function to execute the Bandstop filter

            plt.close()

            try:

                # Verify that the text box is not empty
                if not self.lineEdit_8.text():
                    MensCombo1 = QMessageBox()
                    MensCombo1.setIcon(QMessageBox.Warning)
                    MensCombo1.setWindowTitle("Empty Minimum frequency")
                    MensCombo1.setText("Please, enter a valid Value")
                    returnValue = MensCombo1.exec()

                elif not self.lineEdit_7.text():
                    MensCombo2 = QMessageBox()
                    MensCombo2.setIcon(QMessageBox.Warning)
                    MensCombo2.setWindowTitle("Empty Maximum frequency")
                    MensCombo2.setText("Please, enter a valid Value")
                    returnValue = MensCombo2.exec()

                elif not self.lineEdit_9.text():
                    MensCombo3 = QMessageBox()
                    MensCombo3.setIcon(QMessageBox.Warning)
                    MensCombo3.setWindowTitle("Empty Filter Order")
                    MensCombo3.setText("Please, enter a valid Value")
                    returnValue = MensCombo3.exec()

                elif not self.lineEdit_5.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Trace No. Empty")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.label_4.text():
                    MensCombo4 = QMessageBox()
                    MensCombo4.setIcon(QMessageBox.Warning)
                    MensCombo4.setWindowTitle("Path and file name Empty")
                    MensCombo4.setText("Please, enter a valid Value")
                    returnValue = MensCombo4.exec()

                elif not self.label_7.text():
                    MensCombo5 = QMessageBox()
                    MensCombo5.setIcon(QMessageBox.Warning)
                    MensCombo5.setWindowTitle("Path and Directory name Empty")
                    MensCombo5.setText("Please, enter a valid Value")
                    returnValue = MensCombo5.exec()

                else:
                    # Filtering with a lowpass.

                    plt.close()                                # Close the existing chart.
                    global FPasoBajoMin                        # Se llama a la variable global Tiempo inicial Min en la función
                    global FPasoBajoMax                        # Se llama a la variable global Tiempo Final Max en la función

                    # Lineas para determinar los elementos de la cabecera del archivo, para luego utilizarlas en guardar el registro resultante
                    head, tail = os.path.split(self.archivo_abierto)
                    root, extension = os.path.splitext(tail)

                    archivoFil1 = (self.label_4.text())                         # Lectura etiqueta del Record

                    frecM = (self.lineEdit_8.text())                            # Lectura etiqueta de Frec. Min.
                    frecMax = (self.lineEdit_7.text())                          # Lectura etiqueta de Frec. Max.
                    orden1 = (self.lineEdit_9.text())                           # Lectura del orden del Filter

                    st  = obspy.read(archivoFil1)                               # Lectura archivo de acuerdo al formato

                    # Convertir a flotante el valor string de la caja de texto
                    frec7=float(frecM)                                          # Convierte a flotante el valor de la Frec. Min.
                    frec8=float(frecMax)                                        # Convierte a flotante el valor de la Frec. Max.
                    orden2=int(orden1)                                          # Convierte el valor string del orden del filtro a entero

                    # Ingresar y convertir a entero el valor string de la caja de texto Nº Trazas st[0]
                    NTraza = (self.lineEdit_5.text())                           # Lectura del contenido de la caja de texto Nº Traza st[0]
                    Ntraza2 = int(NTraza)                                       # Convierte el valor del Nº de Traza a entero
                    tr = st[Ntraza2]                                            # Asigna el número de traza indicado al Stream para tratamiento del registro

                    # Realizar una copia para el uso del filtro
                    tr.stats.station
                    tr_filt = tr.copy()
                    s = len(tr)
                    # Calculo del tipo de filtro con sus respectivos parametros
                    tr_filt.filter('bandstop', freqmin=frec7, freqmax=frec8, corners=orden2, zerophase=True)

                    # Calculo del vector de tiempo de acuerdo al registro
                    t = np.arange(0, tr.stats.npts / tr.stats.sampling_rate, tr.stats.delta)

                    t0 = st[0].stats.starttime

                    # Debido a que el velor del tiempo calculado puede diferir del valor del vector de tipo de la traza
                    # Se realiza un calculo de ajuste para que sean iguales de acuerdo al siguiente codigo

                    while (len(t) > len(tr.data)):
                        t = list(t)
                        last_object = len(t) - 1
                        del t[last_object]
                        t = np.array(t)

                    fig, (ax1, ax2) = plt.subplots(2, 1)

                    ax1.plot(t, tr_filt.data, 'k')    # Donde 'k' es el color = black
                    plt.ylabel('Bandstop Filtered Data', color ="blue")
                    plt.xlabel('Time [s]', color ="red")
                    plt.suptitle("Record : %s " % tr.stats.starttime, color ="red")
                    ax1.grid()                                              # presenta la cuadricula en el grafico 1
                    ax2.grid()                                              # presenta la cuadricula en el grafico 2

                    line2, = ax2.plot([], [])

                    # Funcion onselect para poder seleccionar el area de corte en la grafica
                    def onselect(xmin, xmax):

                        # asignación de las variables globales que seran utilizadas en otras funciones
                        global FPasoBajoMin
                        global FPasoBajoMax
                        global TFinal

                        indmin, indmax = np.searchsorted(t, (xmin, xmax))
                        indmax = min(len(t) - 1, indmax)

                        region_x = t[indmin:indmax]
                        region_y = tr.data[indmin:indmax]

                        if len(region_x) >= 2:
                            line2.set_data(region_x, region_y)
                            ax2.set_xlim(region_x[0], region_x[-1])
                            ax2.set_ylim(region_y.min(), region_y.max())
                            fig.canvas.draw_idle()

                            FPasoBajoMin = xmin     # Asigna a la variable global el valor del tiempo inicial de corte
                            FPasoBajoMax = xmax     # Asigna a la variable global el valor del tiempo final de corte

                            # Valores para el calculo del intervalo de corte
                            t0 = st[0].stats.starttime                      # Tiempo inicial de la señal
                            t2 = t0 + FPasoBajoMin*1                        # Tiempo de Inicio para el corte del evento
                            t3 = t0 + FPasoBajoMax*1                        # Tiempo Final para el corte del evento
                            t4 = st[0].trim(t2,t3)                          # Tiempo de recorte inicial y final

                            TFinal = t4                     # Una vez calculado el tiempo de recorte se Asigna a la variable global el valor del corte del evento

                            self.DialogWindows()            # llamada a la función del cuadro de dialogo para guardar el recorte de acuerdo al formato

                    # Codigo que determina el poder seleccionar el area de recorte en la grafica de color azul
                    self.span = SpanSelector( ax1, onselect, 'horizontal', span_stays=True, useblit=True,
                            rectprops=dict(alpha=0.5, facecolor="tab:blue"),
                            interactive=True, drag_from_anywhere=True)

                    plt.show()                              # Hasta aquí se presenta la grafica despues de los calculos


            except:                 # En caso de existir algun error se presenta esta caja de dialogo
                plt.close()                                                 # Close the existing chart.
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("The File Does not exist, is Invalid or the Format is not recognized. Please, try again ...")
                msgBox.setWindowTitle("Invalid Record File")
                returnValue = msgBox.exec()
                pass


    def DialogWindows(self):                                        # Función de ventana de dialogo, la cual es llamada por todos los tipos de filtro

        # Ventana de dialogo (MessageBox) para guardar el corte por formatos SAC y MSEED

        archivoFil1 = (self.label_4.text())                         # Lectura etiqueta del Record
        archivoFil2 = (self.label_7.text())                         # Lectura etiqueta del Directorio

        head, tail = os.path.split(self.archivo_abierto)            # Lectura de las etiquetas de la cabecera del registro

        root, extension = os.path.splitext(tail)                    # Para la lectura de la extension del registro

        dialog = QMessageBox()
        dialog.setWindowTitle("Save the event cut Record")
        dialog.setText("Do you want to save MSEED or SAC Format?, CANCEL = Close all graphics")
        # Se agregan los botones de comando y se realiza la configuración.
        dialog.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel | QMessageBox.No)
        dialog.button(QMessageBox.Ok).setText("MSEED")
        dialog.button(QMessageBox.Cancel).setText("CANCEL")
        dialog.button(QMessageBox.No).setText("SAC")
        # Se determina el tipo de icono de la ventana de dialogo
        dialog.setIcon(QMessageBox.Question)

        # Se ejecuta la ventana de dialogo y se obtine la respuesta de acuerdo a los parámetros
        returnValue = dialog.exec_()
        # Se comprueba el tipo de botón personalizado (MSEED, SAC y CANCEL) que se ha dado clic
        if returnValue == QMessageBox.Ok:                           # En caso de que se ha pulsado el botón OK el registro será MSEED
                        F1 = (root + '.MSEED')
                        F2 = (archivoFil2 + F1)
                        TFinal.write( filename= (F2), format="MSEED")
                        showinfo(title = "File MSEED successfully created", message = "Successfully created record.\n\n")
                        plt.close()
                        print("Formato MSEED")
        elif returnValue == QMessageBox.No:                         # En caso de que se ha pulsado el botón NO el registro será SAC
                        F3 = (root + '.SAC')
                        F4 = (archivoFil2 + F3)
                        TFinal.write( filename= (F4), format="SAC")
                        showinfo(title = "File SAC successfully created", message = "Successfully created record.\n\n")
                        plt.close()
                        print('Formato SAC')
        else:                                                       # En otro caso de que se ha pulsado el botón CANCEL.
                        showinfo(title = "Close all graphics", message = "The plot windows close.\n\n")
                        plt.close()


    """ Function to go back at home """

    def abrir_programa1(self):                                              # Call function to another program (Back)
        if sistema == "Windows":                                            # If the system is Windows
            plt.close()                                                     # Close the existing chart.
            subprocess.Popen(["python", "Menu.py"])
            app.quit()
        else:                                                               # If the system is Linux
            plt.close()                                                     # Close the existing chart
            subprocess.Popen(["python3", "Menu.py"])
            app.quit()


    """  Fuction to exit system  """

    def Exit1(self):                                                        # Call function to show exit dialog box

        msg = QMessageBox()
        msg.setIcon(QMessageBox.Question)
        msg.setWindowTitle("Exit System")
        msg.setText("Are you sure to exit the System?")
        msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        msg.setDefaultButton(QMessageBox.Ok)                                # By default, the focus is on the OK button
        returnValue = msg.exec()
        if returnValue == QMessageBox.Ok:                                   # If the answer is OK
            app.closeAllWindows()                                           # Close all windows



if __name__ == "__main__":

    import sys

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
    # Ligdamis A. Gutiérrez E. PhD.
